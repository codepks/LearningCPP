# LearningCPP

# Introduction
The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86/x64 family, which you may be using) have instructions that can be a variable length. <br>

**Assemly language**, for e.g., ```mov al, 061h``` sits on top of Machine Language which is atleast readable and writable and is still used today when speed is critical. An **Assembler** converts Assembly langugage to Machine langugage. <br>
It is still not very portable. <br>

Much like assembly programs, programs written in high level languages must be translated into a format the computer can understand before they can be run. There are two primary ways this is done: **compiling and interpreting**. <br>

A **compiler** is a program (or collection of programs) that reads source code (typically written in a high-level language) and translates it into some other language (typically a low-level language, such as assembly or machine language, etc…). Over the years, compilers have become very good at producing fast, optimized code, and in some cases can do a better job than humans can in assembly language! <br> 

An **interpreter** is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. But **interpreter** must be installed on every machine where an interpreted program will be run. <br>

Studies have shown that only **20%** of a programmer’s time is actually spent writing the initial program. The other **80%** is spent on maintenance, which can consist of debugging

## Compiler
- Checks for error.
- Second, the compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. Every `.cpp` file generates `.b` or `.obj` file with same name.

## Linker
-  Linker reads in each of the **object files** generated by the compiler and makes sure they are valid.
-  Linker ensures all **cross-file dependencies** are resolved properly. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.
-   Linker also is capable of **linking library files**. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs.

## Build
For building process **make** or **build2** are used 

## Precompiled Headers
Generally comes as an option when we create a project. <br>
In large projects (those with many code files), precompiled headers can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects. <br>

However, precompiled headers require extra work to use, and for small projects (such as those you’ll create in our tutorials) make little to no difference in compilation times. <br>

> **Background** <br>
> When you create a new project in Visual Studio, a precompiled header file named **pch.h** is added to the project. (In Visual Studio 2017 and earlier, the file was called **stdafx.h**.) The purpose of the file is to speed up the build process. <br>
> Any stable header files, for example Standard Library headers such as <vector>, should be included here. The precompiled header is compiled only when it, or any files it includes, are modified. If you only make changes in your project source code, the build will skip compilation for the precompiled header.

[**StackOverFlow**](https://stackoverflow.com/questions/903228/why-use-precompiled-headers-c-c)
<br>In C/C++, the #include mechanism is a textual copy of the file specified into the current file. Headers include other headers (which include yet other headers), so when you do a #include, it could be adding tens of thousands of lines of C++ into each cpp file (or cxx, c, whatever), all of which need to be compiled each time. This can be a severe bottleneck for large projects. <br>

Precompiled headers speed this up by compiling each header once, then including that compiled state into the cpp they are included in. <br>

One important note on Visual Studio: make sure the first #include in each header is #include "stdafx.h". <br>

**Example Usage**

Your automation folder may required a lot of header files which need to be precompiled before your tests start running. 

**stdafx.h**
```
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

// Headers for CppUnitTest
#include <Windows.h>
#include "CppUnitTest.h"

#include "../../../Assets/API/model.engine/Jit__Stage.h"
#include "../../../Assets/API/model.engine/Base__Machine.h"
#include "../../../Assets/API/model.engine/Machine__Flags.h"
#include "../../../Assets/API/model.engine/Engine.h"
#include "../../../Assets/API/model.engine/Shared__Tags.h"
#include "../../../Assets/API/model.engine/Model__Builder.h"
#include "../../../Assets/API/model.engine/Active__Builder.h"
#include "../../../Assets/API/model.engine/Chamber__Actions.h"
#include "../../../Assets/API/model.engine/Json__Helper.h"

#include "gmock/gmock.h"
```

**stdafx.cpp**
```
// stdafx.cpp : source file that includes just the standard includes
// model.engine.Tests.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// The following lines pull in the real gmock *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-cardinalities.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-internal-utils.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-matchers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-spec-builders.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock.cc"

// The following lines pull in the real gtest *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gtest.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-death-test.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-filepath.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-port.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-printers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-test-part.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-typed-test.cc"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
```

Later you to **include** the `stadafx.h` in your mockfiles

```
#pragma once
#include "stdafx.h"
#include "../../../Assets/API/model.__engine/IBuildState__Manager.h"

namespace Cartman {
class MockBuildState__Manager : public IBuildState__Manager {		
public:

	MockBuildState__Manager() { };

	MOCK_METHOD(EPause__Condition, getPause__Condition, (), (const));

	MOCK_METHOD(EState, getCurrent__State, (), ());

	MOCK_METHOD(int, getRemaining__LayersToPause, (), (const));

	MOCK_METHOD(long long, getRemaining__AutoPauseTime, (), (const));

	MOCK_METHOD(void, update, (), ());
};	
```

NOTE: IF you checked the box for creating the precompiler header file and not included the pch.h/stdafx.h in your any of the source files then it will give error and **it should be top of all the headers in a file.**

## Compile, build, rebuild, clean

When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn’t been modified doesn’t need to be recompiled -- the cached object file from last time can be reused. This can speed up compilation times significantly (at the cost of a little bit of disk space). <br>

With that in mind, here’s what each of the options typically does: <br>

- **Build** compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
- **Clean** removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.
- **Rebuild** does a “clean”, followed by a “build”.

## Common C++ Problems

**Q: When compiling my program, I get a ‘no newline at end of file’ error** <br>
> The C++ standard requires that all source (.cpp) files end in a newline. It’s silly, but it is what it is. Go to the bottom of your source file(s), hit enter, save, and recompile

**Q: When I compile my program, I get a warning about "Cannot find or open the PDB file"** <br>
This is a warning, not an error, so it shouldn’t impact your program. However, it is annoying. To fix it, go into the Debug menu -> Options and Settings -> Symbols, and check “Microsoft Symbol Server”.

## Build Configuration

**General Settings**
- What the executable will be named
- What directories the IDE will look in for other code and library files
- Whether to keep or strip out debugging information
- How much to have the compiler optimize your program etc.

### Debug Confiuration
- This configuration turns off all optimizations
- Includes debugging information
- Makes your programs larger and slower
- The debug configuration is usually selected as the active configuration by default

### Release Configuration
 - This version is typically optimized for size and performance, and doesn’t contain the extra debugging information

**GCC/G++ Compiler**
Add `-ggdb` to the command line when debugging and `-O2 -DNDEBUG` for release builds. Use the former for now.

**Disable compiler extension - Visual Studio**
- To disable compiler extensions, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to **All Configurations**.
- Then, click C/C++ > Language tab, and set **Conformance mode to Yes (/permissive-)** (if it is not already set to that by default).
- For GCC/B++You can disable compiler extensions by adding the ```-pedantic-errors``` flag to the compile command line.

### Max warnings
Turn your warning levels up to the maximum, especially while you are learning. It will help you identify possible issues. These are disbaled by default by many compilers and IDEs<br>

**Visual Studio**
<br>
- To increase your warning levels, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to All Configurations.
- Then select C/C++ > General tab and set Warning level to Level4 (/W4).
- Note: Do not choose EnableAllWarnings (/Wall) or you will be buried in warnings generated by the C++ standard library
<br>

**Visual Studio disables signed/unsigned conversion warnings** by default, and those are useful, so if you are using Visual Studio 2019 or newer, let’s enable those <br>
- From C/C++ > Command Line tab, under Additional Options, add /w44365. This tells the compiler to enable signed/unsigned conversion warnings at warning level 4 (which you enabled above).
- From C/C++ > External Includes tab, set External Header Warning Level to Level3 (/external:W3). This tells the compiler to compile standard library headers at warning level 3 (instead of 4) so that compiling those headers doesn’t trigger this warning.

**GCC/G++ Users** <br>
Add the following flags to your command line: -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion

### Warning as Errors
Enable “Treat warnings as errors”. This will force you to resolve all issues causing warnings. <br>
- To treat warnings as errors, right click on your project name in the Solution Explorer window, then choose Properties
- From the Project dialog, first make sure the Configuration field is set to All Configurations
- Then select C/C++ > General tab and set Treat Warnings As Errors to Yes (/WX).
- For GCC/G++ users : Add the following flag to your command line: ```-Werror```

### Exporting Project Templates
- In Visual Studio, this option is available via Project -> Export Template. Select “Project template”, add a name and optional description (e.g. C++20 console application), and then click “Finish”.
- Next time you create a new project, you’ll see this template show up in your list of project templates.
- Once you create a new project with this template, it may not open any files. You can open up your .cpp file in the Solution Explorer window by going to Solution -> <Project Name> -> Source Files -> <template name>.cpp.

# Basics
- Programs typically terminate (finish running) after the last statement inside function main has been executed (though programs may abort early in some circumstances, or do some cleanup afterwards).
- When an executable program finishes running, the program sends a value back to the operating system in order to indicate whether it ran successfully or not. This particular return statement returns the value 0 to the operating system, which means “everything went okay!”
- The main memory in a computer is called **Random Access Memory** (often called **RAM** for short). When we run a program, the operating system loads the program into RAM
- An object with a name is called a **variable** . An instantiated object is sometimes called an **instance**.

## Storage 
Depending on the data segmentation that a particular processor follows, we have five segments:

- **Code Segment** - Stores only code, ROM
- **BSS** (or Block Started by Symbol) Data segment - Stores initialised global and static variables
- **Stack segment** - stores all the local variables and other informations regarding function return address etc
- **Heap segment** - all dynamic allocations happens here

Data BSS (or Block Started by Symbol) segment - stores uninitialised global and static variables.<br>
Note that the difference between the data and BSS segments is that the former stores initialized global and static variables and the later stores UNinitialised ones. <br>

**Every segment has a write protected region where all the constants are stored.** <br>

> For example: <br>
> - If I have a const int which is local variable, then it is stored in the write protected region of stack segment.
>  - If I have a global that is initialised const var, then it is stored in the data segment.
>  - If I have an uninitialised const var, then it is stored in the BSS segment...
>  - In the GCC compiler, on most machines, read-only variables, constants, and jump tables are placed in the text section.

## Types of Initilization

### Default Initilization
 Leaves a variable with an indeterminate value.
```
int a
```

### Copy / Implicit Initilization 
- Copy assignment copies the value on the right-hand side of the = operator to the variable on the left-hand side of the operator
- Copy initialization **had fallen out of favor** in modern C++ due to being **less efficient** than other forms of initialization for some complex types.
```
int width = 5; // copy initialization of value 5 into variable width
```

### Direct / Explicit Initialization
- When an initial value is provided inside parenthesis.
- Direct initialization was initially introduced to allow for more efficient initialization of complex objects
- Just like copy initialization, direct initialization **had fallen out of favor in modern C++**, largely **due to being superseded by list initialization**
- Direct initialization is also used when values are explicitly **cast to another type**
 
```
int width( 5 ); // direct initialization of value 5 into variable width
```

- One of the reasons direct initialization had fallen out of favor is because it makes it hard to differentiate variables from functions. For example:
```
int x();  // forward declaration of function x
int x(0); // definition of variable x with initializer 0
```

### List Initilization
- The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces

```
int width { 5 };    // direct list initialization of initial value 5 into variable width
int height = { 6 }; // copy list initialization of initial value 6 into variable height
int depth {};       // value initialization (see next section)
```
- List initialization was introduced to provide a more consistent initialization syntax (which is why it is sometimes called **uniform initialization** ) that works in most cases contrary to copy initilization and direct initilization
- list initialization is generally preferred over the other initialization forms because it works in most cases, it **disallows narrowing conversions** where as in direct or copy initilization it may to implicit conversions. 
```
int width { 4.5 }; // error: a number with a fractional value can't fit into an int
```
In the above given example list initilization throws error whereas in other cases it will grop the fraction part.

### Value or Zero Initilization
When a variable is initialized using **empty braces**, value initialization takes place
```
int x {};      // value initialization
std::cin >> x; // we're immediately replacing that value
```

### Unused Variables
Sometimes you may leave your variables unused intentionally and compilers give warnings or sometimes errors too,
In order to get over this one case use ```[[maybe_unused]]```

```
int main()
{
    [[maybe_unused]] double pi { 3.14159 };
    [[maybe_unused]] double gravity { 9.8 };
    [[maybe_unused]] double phi { 1.61803 };

    // the above variables will not generate unused variable warnings

    return 0;
}
```

## cout, cin, and endl
- We use `std::cout`, along with the **insertion operator (<<)**
- Insertion operator (<<) can be used multiple times in a single statement to **concatenate** (link together) multiple pieces of output
```
std::cout << "Hello" << " world!";
```

### std::cout is bufferred
Statements in our program request that output be sent to the console. However, that output is typically not sent to the console immediately. Instead, the requested output “**gets in line**”, and is stored in a region of memory set aside to collect such requests (called a buffer). Periodically, the buffer is flushed, meaning all of the data collected in the buffer is transferred to its destination (in this case, the console). <br><br>

This also means that if your program crashes, aborts, or is paused (e.g. for debugging purposes) before the buffer is flushed, any output still waiting in the buffer will not be displayed. <br>
Writing data to a buffer is typically fast, whereas transferring a batch of data to an output device is comparatively slow. <br>

### std::endl vs '\n'
The ‘\n’ character moves the cursor to the next line of the console, but doesn’t request a flush, so it will often perform better whereas std::endl works on buffer methodology

### std::cin 
**>>** is called **extraction operator** called in case if std::cin

```
int x{}; //It is a good practice to initialize a variable before being used
std::cin >> x;
```

## Uninitialized Variable
When a variable that is not initialized is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in that memory address. <br>

**Potential performance issue** <br>
Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.<br>

If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you’re overwriting those values anyway). <br>

You should always initialize your variables because the cost of doing so is minuscule compared to the benefit.

**Visual Studio Presetting** <br>
Visual Studio, will initialize the contents of memory to some **preset value** when you’re using a **debug build configuration**. This will not happen when using a release build configuration. Therefore, if you want to run the above program yourself, make sure you’re using a release build configuration.

## Keyword and convenstions :
- Underscores used for variables and intercaps used for functions.
- You should avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- A good rule of thumb is to make the length of an identifier proportional to how widely it is used . `i` vs 'count`

## Whitespacing and formatting
**Lines should not be too long** <br>
Typically, 80 characters has been the de facto standard for the maximum length a line should be. If a line is going to be longer, it should be split (at a reasonable spot) into multiple lines. <br> You can have extensions/plugin for **column guide** <br>

If a long line is split with an operator (eg. << or +), the operator should be placed at the beginning of the next line, not the end of the current line
```
std::cout << 3 + 4
    + 5 + 6
    * 7 * 8;
```

**One exception**: If you are working in someone else’s code base, adopt their styles. It’s better to favor consistency than your preferences.

## Operators 

### Arity
**Unary** : `-` is an example. '5' -> `-5` it flips the sign of the variable <br>
**Binary** : `+`, `<<`, `>>` uses two operaands to work over like `3+4` or s`td::cout << x`
**Ternary** : Requires 3 operands to operate like `?`
**Nullary** : like `throw`

### Precedence
- `operator+` and `operator*` return sum and product value
- `operator=` and `opearator<<` behave differently. `x = 5` returns x and `std::cout << 5` returns `std::cout`
- `x = y = 5` evaluates as `x = (y = 5)`. First `y = 5` assigns `5` to `y`. This operation then returns `y`, which can then be assigned to `x`
- `std::cout << "Hello " << "world"` evaluates as `(std::cout << "Hello ") << "world!"` . This first prints `"Hello "` to the console. This operation returns `std::cout`, which can then be used to print `"world!"` to the console as well.

## Expressions
```
int x{2+3};
```
The statement above can be translated as:
```
type identifier{Expression};
```

**Expression** is a sequence of literals, variables, operators and funtions calles that calculates a single value. Process of doing that is called **evaluation** and output is called **result** <br>

> std::cout << x evaluates to the object std::cout <br>
> This allows us to do things like std::cout << x << y << z and have it work properly. If operator<< returned nothing, then after x was output, it wouldn't know where to send y and z <br>

**Expression Statement** : These are statements that consists of an expression followed by a semicolor. E.g. `x = 5;` A return value is geenrated from it , here it is `x` but it is discarded since it is not used. <br>

## Best Practice
New programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add **one piece at a time**, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece. <br>


# Virtual Table
When a function contains virtual function than virtual table corresponding to that class is generated during compile time.

Let's look at virtual table of this class:

```class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n\n"; };

};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n\n"; };

};
```

Virtual table of Base class:
*BaseClass contains a virtual function func2().
When an object of BaseClass is created, it contains a hidden virtual pointer (vptr) that points to the vtable of BaseClass.*
```
BaseClass vtable:
---------------------
| 0: Address of func2() |
---------------------
```
Virtual table of Derived class:

*DerivedClass also contains a virtual function func2(), which overrides the same function in BaseClass. When an object of DerivedClass is created, it contains a vptr that points to the vtable of DerivedClass.*
```
DerivedClass vtable:
---------------------
| 0: Address of DerivedClass::func2() |
---------------------
```

When a class is polymorphic (contains virtual functions), the compiler creates a hidden pointer in each object of that class. This pointer, called the **virtual pointer (vptr)**, points to the vtable of the dynamic type of the object.

# Static vs Dynamic vs Reinterpret Cast

## Static Casting
Static casting is done when you know the data types already:
E.g. conversion of float to int. The type is known during compile time.

## Dynamic Casting
Dynamic casting is done when the classes involved in conversion have virtual function and their behaviour is known during run time.
Types : Upcasting - derived to parent case class, where loss of information happens
Downcasting : parent to derived class : information can be restored.

```
class Base {
    virtual void foo() {};
};

class Derived : public Base {
    void foo () {};
};

Base* basePtr = new Derived;	//Upcasting - Loss of Information
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);	//Downcasting - Retrieve back information

if (derivedPtr) {
    // Successfully casted
} else {
    // Cast failed
}
```

### Casting Failure

```
class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n"; };
};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n"; };
};

int main()
{
	BaseClass *base = new BaseClass();
	base->func2();
	//downcasting
	DerivedClass* derived = dynamic_cast<DerivedClass*>(base); 

	derived->func2();
	// *Casting fails*
}
```

The dynamic casting fails because, intially base pointer points to BaseClass object.
In the dynamic casting we are making DerivedClass pointer point to Base class object where it fails.

```
DerivedClass* derived = dynamic_cast<DerivedClass*>(base);
```
During Dynamic Casting, the casting checks if the object being pointed to (Base class here by base *) by a pointer(Derived Class pointer here) is an instance of Derived Class or not.


## Reinterpret_Cast
It doesn't work on the basis of polymorphic behavior like Dynamic casting does.

In the code below:
```
DerivedClass* derived = reinterpret_cast<DerivedClass*>(base);
```
reinterpret_cast takes the BaseClass pointer base and forcefully reinterprets the bits of its address as if they were a DerivedClass pointer.
**It simply creates a new pointer of the target type with the same memory address as the original pointer.**

Since derived is a DerivedClass pointer, the compiler expects a DerivedClass object with its own virtual function table (vtable).
However, the actual object doesn't have a vtable for DerivedClass. It only has the vtable for BaseClass.
When derived->func2(); is called, the compiler incorrectly looks up func2 in the DerivedClass vtable, but it finds the base class version instead.  

reinterpret_cast only changes the pointer's type, not the underlying object's layout or behavior.
It doesn't magically insert the missing derived class members or vtable into the BaseClass object.
Technically, attempting to call a derived class function on a BaseClass object using a reinterpret_cast pointer is undefined behavior in C++.

# Function Pointers

## Typedef
```
typedef return_type (*FunctionPtr)(parameter_types...);

typedef void (*MyFunctionPtr)();
```

## using 
```
using FunctionPtr = return_type (*)(parameter_types...);

using MyFunctionPtr = void (*)();
```

## std::function
```
using FunctionType = std::function<return_type(parameter_types...)>;

using MyFunctionType = std::function<void()>;
```

# C-Style enums vs Class Enums

## Intro
C-Style enums
```
enum Color {green, yellow, blue};

int main()
{
	std::cout << green; //works
}
```

Class enums
```
enum Class Color {green, yellow, blue};

int main()
{
	std::cout << green;	   //doesn't work
	std::cout << Color::green; //works
}
```

## Differences
enum classes are better in these many ways:

1. enum classes can be type specified
```
enum class Color : unsigned int {  // Enum class with underlying type specified
    Red = 1,
    Green,
    Blue };
```

2. enum values can be initialized
```
enum class Day {  // Enum class without specified underlying type
    Monday = 1,
    Tuesday,
    Wednesday };
```

# Functions
**A function call is an expression that tells the CPU to interrupt the current function and execute another function.** <br>
```
returnType Identifier {Functio body}
```
Our main function should return `0` to indicate that it ran normally, other values mean failure due to error throw. <br>

The C++ standard only defines the meaning of 3 status codes: `0`, `EXIT_SUCCESS`, and `EXIT_FAILURE`. `0` and `EXIT_SUCCESS` both mean the program executed successfully.  <br> EXIT_FAILURE means the program did not execute successfully. <br>

`EXIT_SUCCESS` and `EXIT_FAILURE` are preprocessor macros defined in the <cstdlib> header:
```
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE
int main(){
    return EXIT_SUCCESS;
}
```

The only exception to the rule that a value-returning function must return a value via a return statement is for function `main()`. The function `main()` will implicitly return the value `0` if no return statement is provided. <br>

## Parameters 
**A function parameter** is a variable used in the header of a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are **initialized with a value provided by the caller of the function**. <br>
```
int add(int x, int y){  //x and y are function parameters
    return x + y;
}
```
An **argument** is a value that is passed from the caller to the function when a function call is made:
```
doPrint(); // this call has no arguments
printValue(6); // 6 is the argument passed to function printValue()
add(2, 3); // 2 and 3 are the arguments passed to function add()
```
When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter (using **copy initialization ("=")**). <br>

in `add(2,3)` `2` is copied to `x` and `3` is copied to `y` via `x = 2` and `y = 3` <br>

Arguments are the expressions that get resolved before being passes <br>
```
add(1, multiply(2, 3)) //here multiply woul dbe resolved first
```
## Scope
Scope is property of an identifier <br>

## Temporary Objects
```
int getValueFromUser(){ 	
	int input{3};	
	return input; // return the value of input back to the caller
}

int main(){
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored in this called?
	return 0;
}
```

In the code above :
- `getValueFromUser()` returns the value stored in local variable `input` **back to the caller**
- caller receives a **copy of the value** so that it has a value it can use even after `input` is destroyed
- The return value is stored in a **temporary object**. This temporary object is then passed to `std::cout` to be printed
- Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier) an is destroyed after ```std::cout << getValueFromUser() << '\n'``` executes.
- In the case where a temporary object is used to initialize a variable, the **initialization happens before the destruction of the temporary**.
- In modern C++ (especially since C++17) this step is skipped, use the return value of `getValueFromUser()` to directly initialize the parameter of `operator<<`.

## Forward Declaration

 - A forward declaration or a function prototype allows us to tell the compiler about the **existence of an identifier before actually defining the identifier**
 - This way when compiler encouters a function call, having gone through forward declaration it will understand that we're making a correct function call even if doesn't know where is function defined.
 - It is helpful in a scenrio where **caller()** and **callee()** are in different file or for functions having **circular dependencies** like below.
 - In C++ we forward declare the variable/function with its **type and name without its definition**, so that we can use its body. Doing this save **unncessary compilation**.

_Example_
```
//someFile.hpp
class Class;
void f(Class object);
```

```
#include <iostream>

void funcA(); //Function prototype
void funcB();

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // this works because we forward declared add() above
    return 0;
}

void funcA() { funcB(); };
void funcB() { funcA(); };
```

The interdependent functions call can only be solved by forward declration.

## Function without body
```
int add(int x, int y); // forward declaration of add()

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```
In the code above, on compilation it will reach only upto object file creation case but would fail in linking as the **linker would not be able to find the definition of the declaration**. <br>

**One definition rule** : You can forward declare as many times as possible but definition can exist only once

## Calling  Conventions

[source] (https://www.geeksforgeeks.org/calling-conventions-in-c-cpp/) <br>

Generalization :
```
return_type calling_convention function_name {
    // statements
}
```

```
int __cdecl cdeclAdd(int a, int b);

int __stdcall stdcallAdd(int a, int b)  ;
  
int __fastcall fastcallAdd(int a, int b, int c, int d);
  
class Temp { 
public: 
    int __thiscall thiscallAdd(int a, int b) ;
}; 
```

Calling convetions decides: <br>
1. How arguments are passed on stack
2. Who will clear the stack : caller or callerr ?
3. What registers will be used and how

**__cdecl**  
- It is the **default** calling ocnvention
- **Caller** cleans the stack. i.e. m**ain()::result = cdeclAdd(1, 2);** clears the stack
- reates larger executables than __stdcall, because it requires each **function call to include stack cleanup code**. (optimiization scope)

**__stdcall**
- This is a **Microsoft-specific calling convention** used by Win32 API functions
- Callee cleans the stack.

**__fastcall**
- Callee cleans the stack

**__thiscall**
- It is the **default** calling convention used by methods inside a **class**
- Callee cleans the stack
- Since we pass **this** pointer as well, we cannot use this calling convention for non-member functions

## Declaration vs Definition
source is [here](https://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/)
- **Declaration** tells compiler about existense of a variable/function/symbol and it memory address and required storage may not be defined
- **Definition** tells the compiler about what the body of the variable/function/symbol contains and how much memory is required to store it
- In case of reference variables and pointers declarations along with definitions is necessary. In case of pointers they need to have a fixed memory independent of the memory type they are pointing to, in face in deferencing the pointer definition becomes important.

**Functions** <br>
```
int f();               // declaration
int f() { return 42; } // definition
```

**Variables** <br>
```
int x;		//both a declaration and definition
```
x in the case above is initialised with 0 via default constructor of int. <br>

**Separating Declaration and Definition for variables** <br>
```
extern int x; // declaration
int x = 42;   // definition
```

In C++, all definitions are declarations. Conversely, not all declarations are definitions. <br>

A declaration is sufficient to allow the compiler to ensure an identifier is being used properly. For example, when the compiler encounters function call `add(5, 6)`, if it has already seen the declaration for `add(int, int)`, then it can validate that add is actually a function that takes two int parameters. It does not need to have actually seen the definition for function add (which may exist in some other file). <br>

**Contradiction** <br>
There are a few cases where the compiler must be able to see a full definition in order to use an identifier (such as for template definitions and type definitions.

## One Definition Rule

 - **Within a file**, each function, variable, type, or template can only have one definition. Not applicable to functions defined inside different namespaces. Violating this can cause **redefinition error**
- **Within a program**, each function or variable can only have one definition. This rule exists because programs can have more than one file. Violating this can cause to show **Linker to issue a redefinition error**
- Types, templates, **inline** functions, and **inline** variables are allowed to have duplicate definitions in different files, so long as each definition is identical. Violating this will cause **undefined** behavior.

**What can go wrong ?**
Suppose you have a file.h where you have declared a **_global_ function** and also defined in the same file :
```
//file.h
int add(int, int);

int add (int a  int b) {
return a + b;
}
```

Now, you have included this in different files:
```
//A.cpp
#include <file.h>
add(3,5);

//B.cpp
#include <file.h>
add(5,6);

//C.cpp
#include <file.h>
add(6,7);
```

Since you have declared the function globally, you have exposesd it to the **Linker** and when compiled it will search for its definition and it will **see its definition multiple files** instead of one file and due to this it will through multiple redefinition error.

## Extern "C" and Name Mangling
[source](https://www.geeksforgeeks.org/extern-c-in-c/)

C++ does name mangling to all the function in order to **add information of the arguments with the function name**. <br>
```
int f(void) { return 1; }
//becomes this
int __f_v(void) { return 1; }
```

This technique helps to resolve _function overloading_. <br>

But this can be an issue in case we are trying to use C library inside C++ file as C++ compiler may mangle their function names too and since C doesn't support name mangling the C functions will give error.

For e.g.
```
int printf(const char* format, ...); // a C function
 
// Driver Code
int main()
{
    printf("GeeksforGeeks");
    return 0;
}
```
This wold give error as `printf` is mangled something like `__printf__char`  by C++ and `printf("Geeks...)` isn't able to find `printf` anymore. <br>
To avoid name mangling of C functions in C++ class we use **extern "C"** .
```
// CPP Program to demonstrate Extern "C"

extern "C" {
int printf(const char* format, ...);
}

// Driver Code
int main()
{
	printf("GeeksforGeeks");
	return 0;
}
```

## Multiple Files
Remember, compiler compiles each `.cpp` file individually and makes `.o` object files and not '.h` files. <br>

```
//main.cpp
#include <iostream>

int add(int x, int y); // needed so main.cpp knows that add() is a function defined elsewhere

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```
The compiler compiles the file above into `main.o`, sees the function declaration of ```int add(int x, int y);``` and validates it for `add(3,4)` makes the object file. Linker then then searches for the definition for the function symbol ```int add(int x, int y);``` and searches for the definition across the different object files. 
```
//add.cpp
int add(int x, int y) //this is a gloable definition
{
    return x + y;
}
```
- Linker finally finds the symbol definition in add.cpp which is a **global definition** and finally links for the object files and this program finally compiles error free to give output `7`.
- Also, The **same wouldn't work** if you had made the definition in a 'add.h' file and it doesn't get converted in object file and linker wouldn't be able to file it in any object file.
- Also, don't include `add.cpp` in the `main.cpp` file as linker would find multiple defitions of add() function in `add.o` and `main.o`

**Making the definition local using namespace:** <br>
We can break the linker from working by making the global definition local by using namespace:
```
namespace{
	int add(int x, int y)
	{
		return x + y;
	}
}
```
Now this function is **no more exposed to linker** and compiler would give linker error issue.

## Namespaces

### Name Collision
```
//a.cpp:
#include <iostream>
void myFcn(int x){
    std::cout << x;
}
```
```
//main.cpp:
#include <iostream>
void myFcn(int x){
    std::cout << 2 * x;
}
int main() {
 return 0;
}
```
On compiling the code above, each individual file would compile properly but when it would come to Linker it would find duplication of defition of myFcn() (defition is also declration).

### Namespaces

The solution to above code is putting namespace to either of the definition to make the definition local to the file and then that defitniion can be accessed via namespace scope resolution. 
```
//main.cpp:
#include <iostream>
namespace SomeSpace{ void myFcn(int x){
    std::cout << 2 * x;
}
}
int main() {
SomeSpace::myFcn(3);
return 0;
}
```
Now defintions wouldn't collide as function defined inside namespace is not exposed to linker directly.

> **Notes** <br>
> Two identically named functions can be defined inside separate namespaces, and no naming collision will occur <br>
> Namespaces are often used to group related identifiers in a large project <br>
> You can only place declarations and definitions, not executable statements directly <br>
```
namespace MyNamespace {
  // OK: Variable declaration
  int myVariable;

  // OK: Function declaration
  void myFunction();

  // NOT OK: Executable statement directly within namespace
  x = 5; // This would cause a compiler error
}
```

### Global Namespace

```
//a.cpp:
#include <iostream>
void myFcn(int x){
    std::cout << x;
}
```

Here myFcn() is defined inside a global namespace. <br>

- Identifiers declared inside the global scope are in scope from the point of declaration to the end of the file.

### std namspace
- When you use an identifier that is defined inside a namespace (such as the std namespace), you have to tell the compiler that the identifier lives inside the namespace
- Use explicit namespace prefixes to access identifiers defined in a namespace.

```
#include <iostream> // imports the declaration of std::cout into the global scope
using namespace std; // makes std::cout accessible as "cout"
int cout() { // defines our own "cout" function in the global namespace
    return 5;
}

int main(){
    cout << "Hello, world!"; // Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?

    return 0;
}
```

The above code shows compiler here as cout defitnition is ambigous.

## Preprocessor
- Every code goes through preprocessing phase before compilation
- After preprocessing a file is called a **translation unit**

### Preprocessor Directives
- They are instructions that start with **#** and end with **newline**
- Preprosessor doesn't understand C++ syntax as it has its **own syntax**

### Macros
There are two types:
- Object-like macros - ``` #define DEBUG "debug" ```
- funtion-like macros - ```#define AREA(length, width) (length * width)```


They are more often seen in legacy code and have been replace with constant variables etc.

### Conditional Compilation

**#ifdef (#if defined() ), #ifndef (#if !defined()), and #endif** <br>
- The #ifdef preprocessor directive allows the preprocessor to check whether an identifier has been previously **#defined**. If so, the code between the #ifdef and matching #endif is compiled. If not, the code is ignored.
- #ifndef is the opposite of #ifdef, in that it allows you to check whether an identifier has NOT been #defined yet.

```
#define PRINT_JOE
int main(){
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n"; // will be excluded since PRINT_BOB is not defined
#endif
   return 0;
}
```
Only defined directive code will be compiled and others would be ignored

### #if 0
It can be used in a code to void from being compiled and it behave as if it is **inside a comment block**.

### Scope

```
void foo(){
#define MY_NAME "Alex"
}

int main(){
	std::cout << "My name is: " << MY_NAME << '\n';
	return 0;
}
```

- Preprocessor  doesn’t understand C++ concepts like functions.Therefore, this program behaves identically to one where #define MY_NAME “Alex” was defined either before or immediately after function foo()
- Directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.


```
// function.cpp
void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!\n";
#endif
#ifndef PRINT
    std::cout << "Not printing!\n";
#endif
}
```

```
// main.cpp
void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main(){
    doSomething();
    return 0;
}
```

The above program will print: <br>

**Not printing!**

## Header Files

The primary purpose of a header file is to **propagate declarations** to code (.cpp) files. <br>


```
//add.h:
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

```
//main.cpp:
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main(){
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

```
//add.cpp:
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
int add(int x, int y){
    return x + y;
}
```
In the code above the compiler still compiles well without adding add.h in add.cpp since it can find definition while linking process. 
 - By including its own header, add.cpp becomes a **self-sufficient module**. It can be used in other projects without requiring modifications to those projects' header files.
 - Including the header guarantees that the function's declaration and definition precisely match

```
// something.h:
int something(int); // return type of forward declaration is int
```
```
//something.cpp:
#include "something.h"
void something(int) // error: wrong return type
{
}
```

Including something.h in something.cpp would help to check if the declarations and definitions are matching or not and this we can get verified while compiling the individual source file something.cpp itself insted of jumping to compiling whole source code.

### Other Dir headers
The below given code shows bad practice to include headers in your file, know as **relative path to the header file**  :
```
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

Downsides to it <br>
1.  It requires you to reflect your directory structure in your code
2.  If you ever update your directory structure, your code won’t work anymore

**Better Method** <br>
A better method is to tell your compiler or IDE that you have a bunch of header files in some other location, so that it will look there when it can’t find them in the current directory. E.g. **Include Directories** in Visual Studio

### Include necessary headers
The best practice says that if your file requires a header <someheader> but that is already included by some other header <otherheader> which already includes <someheader> and you feel no need to include the <someheader> explicitly then you should't do so. <br>
If something goes wrong with <otherheader> then you would lose <someheader> as well, that's why you should explicity include <someheader> file too if it is required.

### Order of headers
It can matter if there is a dependency of declrations for e.g. header A depending on header B, then B shuold be included first then A.

**Best Practice** 
1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

## Header Guards

```
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```
Including header guards in your header file prevents your code from having mulitple copies of definitions / declarations(although multiple declarations is allowed) / **classes** etc. <br>

It is always good to have unique header guard names to avoid conflict of same name header file in a large project.

## pragma once
It serves the same purpose as header guards but complex cases header guards is still preferable over pragma once and it is followed by Google too.<br>
#pragma once is **not defined by the C++ standard**, it is possible that some compilers may not implement it.

## Design your first Program
1. Design step 1: Define your goal
2. Design step 2: Define requirements
3. Design step 3: Define your tools, targets, and backup plan
4. Design step 4: Break hard problems down into easy problems
5. Design step 5: Figure out the sequence of events

### Implementation
1. Outline your cod ein main function
```
int main()
{
//    doBedroomThings();
//    doBathroomThings();
//    doBreakfastThings();
//    doTransportationThings();

    return 0;
}
```

2. Implement each function
```
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
```

# Debugging

- First step is th reproduce the problem
- Comment your code
- OR Validate your code flow/do a DRY run
- Print the values
- Use `std:cerr` over `std::cout` as cout is more bufferred and cerr is not as it imidiately outputs the value. Cout may or may not show output in case of crash but `cerr` does. On the other hand, `std::cerr` is unbuffered, which means anything you send to it will output immediately

## Advance debugging

### Conditional Compilation
```
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
```
- If this were a multi-file program, the `#define ENABLE_DEBUG` would go in a header file that’s included into all code files so we can comment / uncomment the #define in a single location and have it propagate to all code files.
- Another downside of this approach is that if you make a typo (e.g. misspell “DEBUG”) or forget to include the header into a code file, some or all of the debugging for that file may not be enabled. `

## Logger
One can use one of the many existing third-party logging tools available

```
#include <plog/Log.h> // Step 1: include the logger headers
#include <plog/Initializers/RollingFileInitializer.h>
#include <iostream>

int getUserInput(){
	PLOGD << "getUserInput() called"; // PLOGD is defined by the plog library

	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main(){
	plog::init(plog::debug, "Logfile.txt"); // Step 2: initialize the logger
	PLOGD << "main() called"; // Step 3: Output to the log as if you were writing to the console
	int x{ getUserInput() };
	std::cout << "You entered: " << x << '\n';

	return 0;
}
```

# Fundamental Data Types

## Introduction
- Bit is a smallest unit of a data
- In modern computer architectures, each bit does not get its own unique memory address.Instead they are stored in chunks of data and collective bits or int + bits can have unique memory address, it is **1 byte of chunk** in C++ 
- Many of the types defined in newer versions of C++ (e.g. std::nullptr_t) use a **_t suffix**. This suffix means “**type**”

## Void

- It means no datatype
- The compiler knows about the existence of such types, but **does not have enough information to determine how much memory to allocate** for objects of that type
- `void` is intentionally incomplete since it represents the lack of a type, and thus cannot be defined

```
void value; // won't work, variables can't be defined with incomplete type void
```

**Usage** <br>
- `void` is used to indicate that a function does not return a value
- In C, void is used as a way to indicate that a function does not take any parameters
```
int getValue(void) // void here means no parameters
{
    int x{};
    std::cin >> x;

    return x;
}
```
- Void has more advance usage in form of **void pointers**

## size of objects
The sizeof operator is a unary operator that **takes either a type or a variable**, and returns its size in bytes <br>
NOTE : **sizeof** does not include dynamically allocated memory used by an object.

## signed integers
- In binary representation, **a single bit** (called the sign bit) is used to store the sign of the number
- The **non-sign bits** (called the magnitude bits) determine the magnitude of the number

### Range
- 8-bit integer contains 8 bits. 28 is 256, so an 8-bit integer can hold **256** possible values. There are 256 possible **values between -128 to 127**
- Out of 8 bits 1 bit is used to store the sign and rest 7 bits are used to store the magnitude
- Assigning value more than range can lead to **overflow** and undefined behaviour

Overflow case :
```
#include <iostream>

int main()
{
    // assume 4 byte integers
    int x { 2'147'483'647 }; // the maximum value of a 4-byte signed integer
    std::cout << x << '\n';

    x = x + 1; // integer overflow, undefined behavior
    std::cout << x << '\n';

    return 0;
}
```
output is 
```
2147483647
-2147483648
```
### Division
When doing division with two integers (called integer division), C++ always produces an integer result

## Unsigned Integers
Unsigned integers are integers that can only hold non-negative whole numbers. <br>

### Overflow
**If an unsigned value is out of range, it is divided by one greater than the largest number of the type, and only the remainder kept.** <br>

E.g. The number 280 is too big to fit in our 1-byte range of 0 to 255. 1 greater than the largest number of the type is 256. Therefore, we **divide 280 by 256, getting 1 remainder 24**. The remainder of 24 is what is stored. <br>

Any number bigger than the largest number representable by the type simply “**wraps around**” (sometimes called “modulo wrapping”) <br>

**Positive Wrapping**
If +ve value of greater than range is added then it gets truncated

**Negative Wrapping**
If -ve value is entered against the unsigned number **it wraps around to the top of the range**. <br>
E.g. In a 2-byte unsigned integer, -1 is not representable, so it wraps around to the top of the range, producing the value 65535. -2 wraps around to 65534. 

### Avoiding Unsigned Integers
1. It can easily introduce overflow in case of **subtraction** and **loops** having continous decrement
```
int main(){
	unsigned int x{ 2 };
	unsigned int y{ 3 };

	std::cout << x - y << '\n'; // prints 4294967295 (incorrect!)

	return 0;
}
```
```
Output : 4294967295 <br>
```

2. In C++, if a mathematical operation (e.g. arithmetic or comparison) has one signed integer and one unsigned integer, the **signed integer will usually be converted to an unsigned integer**
```
int main()
{
	unsigned int u{ 2 };
	signed int s{ 3 };

	std::cout << u - s << '\n'; // 2 - 3 = 4294967295

	return 0;
}
```

### When to use?
1.  unsigned numbers are preferred when dealing with **bit manipulation**
2.  useful in some algorithms like encryption and random number generation
3.  use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing
4.  If you’re developing for an embedded system use of unsigned numbers is more common and accepted for performance reasons.

## Fixed Width Integers
**Why ?** 
C opted to intentionally leave the size of an integer open so that the compiler implementers could pick a size for int that performs best on the target computer architecture. <br>

**C99** defined a set of fixed-width integers (in the stdint.h header) that are guaranteed to be the same size on any architecture.
> E.g. **std::int16_t** with range **-32,768 to 32,767** <br>

They are available under `<cstdint>`<br>

### Downsides
**First**, Your program will fail to compile on any such architecture that does not support a fixed-width integer that your program is using. However, given that most modern architectures have standardized around 8/16/32/64-bit variables, this is unlikely to be a problem <br>

**Second**, if you use a fixed-width integer, it may be slower than a wider type on some architectures. or example, if you need an integer that is guaranteed to be 32-bits, you might decide to use std::int32_t, but your CPU might actually be faster at processing 64-bit integers.

NOTE : When storing integral values where a specific size is important, it’s generally best to **avoid std::int8_t and std::uint8_t.**

### Best Practice
1. Prefer int when the size of the integer doesn’t matter
2. Prefer std::int#_t when storing a quantity that needs a guaranteed range
3. Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required

### std::size_t
```
std::cout << sizeof(int) << '\n';
```
The return value of sizeof is an size_t and its capacity is 4 bytes and with this it limits the maximum size of object to be 2^32

## Float type
- When using floating point literals, always **include at least one decimal place** (even if the decimal is 0). This helps the compiler understand that the number is a floating point number and not an integer
- Floating point literals default to type double. An f suffix is used to denote a literal of type float

```
int x{5};      // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
```

 NOTE : A 4 bytes floating type variable has 6-9 singnificant digits. <br>

 ### Override Precision
 We can override the default precision that std::cout shows by using an output manipulator function named **std::setprecision()**. Output manipulators alter how data is output, and are defined in the iomanip header. <br>

### Best Practice 
Favor **double over float** unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.

### Nan and Inf
- **Inf**, which represents infinity. Inf can be positive or negative
- **NaN**, which stands for “Not a Number”

```
double zero {0.0};
double posinf { 5.0 / zero }; // positive infinity
std::cout << posinf << '\n';

double neginf { -5.0 / zero }; // negative infinity
std::cout << neginf << '\n';

double nan { zero / zero }; // not a number (mathematically invalid)
std::cout << nan << '\n';
```
OUTPUT:
```
1.#INF
-1.#INF
1.#IND
```

## Boolean Values
```
bool isEqual(int x, int y)
{
    return x == y; // operator== returns true if x equals y, and false otherwise
}
```
`operator==` is a binary operator that inputs two values, here its `x` and `y` and return bool value.

In boolean value `false` is as `0` is inte
## Chars
The char data type was designed to hold a **single character** <br>
A character can be a single letter('A'), number (1), symbol(#), or whitespace(` `) <br>

- The **integer** stored by a char variable is intepreted as an **ASCII** character
- Character literals are always placed between **single quotes** (e.g. ‘g’, ‘1’, ‘ ‘)
- Codes 0-31 are called the unprintable chars
- Codes 32-127 are called the printable characters
- This way all the 0-127 value range is utilized in 8 bit character datatype except for negative value range

```
char ch2{ 'a' }; // initialize with code point for 'a' (stored as integer 97) (preferred)
char ch{5}; // initialize with integer 5 (stored as integer 5)
char ch{'5'}; // initialize with code point for '5' (stored as integer 53)

char ch2{ 98 }; // code point for 'b' (not preferred)
std::cout << ch2; // cout prints a character ('b')
```

**std::cin is a buffered input** <br>
```
std::cout << "Input a keyboard character: "; // assume the user enters "abcd" (without quotes)

char ch{};
std::cin >> ch; // ch = 'a', "bcd" is left queued.
std::cout << "You entered: " << ch << '\n';

// Note: The following cin doesn't ask the user for input, it grabs queued input!
std::cin >> ch; // ch = 'b', "cd" is left queued.
std::cout << "You entered: " << ch << '\n';
```
### Single Quote vs double quotes
Single chars are always put in **single quotes** to represent one symbol. <br>
Text between **double quotes** (e.g. “Hello, world!”) is treated as a string of multiple characters <br>

### Unicode
The most well-known mapping outside of ASCII is the Unicode standard, which maps over 144,000 integers to characters in many different languages. Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called UTF-32). However, Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called UTF-16 and UTF-8 respectively).

### wchar_t, char8_t, char16_t, and char32_t
**wchar_t** should be avoided in almost all cases (except when interfacing with the Windows API). Its size is implementation defined, and is not reliable. It has largely been deprecated. <br>
You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible. <br>

## Type Conversion
When the compiler does type conversion on our behalf without us explicitly asking, we call this **implicit type conversion** <br>

### Implicit Conversions
```
void print(double x){
	std::cout << x << '\n';
}

int main(){
	int y { 5 };
	print(y); // y is of type int
}
```
**Safe type conversion** : The conversion does not change variable `y` from type int to double. Instead, the conversion uses the value of `y` (5) as input to create a new double value (5.0). This double value is then passed to function print via **direct initilization** .<br>
**Unsafe TYpe Conversion** :In opposite case of converting 5.5 to 5 i.e double to int might show data loss warning. 

### Explicit Conversions
The variable itself is not affected by casting its value to a new type <br>
**For Removing Warning**
```
void print(int x){
	std::cout << x << '\n';
}

int main(){
	print( 5.5 ); // explicitly convert double value 5.5 to an int
	return 0;
}
```

The above code will give warning over type conversion from float to int leading to data loss. <br>
In order to remove the warning and telling the compiler that the conversion is explicit we need to use `static_cast`

```
print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int
```

**For static cast character to value**

```
int main(){
    char ch{ 97 }; // 97 is ASCII code for 'a'
    std::cout << ch << " has value " << static_cast<int>(ch) << '\n'; // print value of variable ch as an int

    return 0;
}
```
This outpurs:
```
a has value 97
```

**Converting unsigned numbers to signed numbers**
```
unsigned int u { 5 };
int s { static_cast<int>(u) }; // return value of variable u as an int
```

But if the input value is out of range for int then it will give undefined behaviour <br>



# Constants and Strings

## Constant Variables
2 types:
1. **Named contants** : associated with an identifier. E.g. Constant variables, Constant variables, Enumerated constants 
2. **Literal constants** : not associated with an identifier

## Named Constants
It is preferred to have constant **before type**: 
```
const double gravity { 9.8 };  // preferred use of const before type
int const sidesInSquare { 4 }; // "east const" style, okay but not preferred
```

Const variables **must** always be **initialized** :
```
const double gravity; // error: const variables must be initialized
gravity = 9.9;        // error: const variables can not be changed
int age{5};
const int constAge {  age }; //They can be initilized with non-const variables
```
### Constant Function Parameters
Making a function parameter constant enlists the compiler’s help to ensure that the parameter’s value is not changed inside the function.
```
void printInt(const int x){
    std::cout << x << '\n';
}
```
```
printInt(5); // 5 will be used as the initializer for x
```
NOTE : **Don’t use const when passing by value.** Anyway the constant variable would be destroyed and there is not point if passed by value and we have made it a constant. _const is preferred in pass by reference generally_

### Cost return values
```
const int getValue(){
    return 5;			// we are returning by value over here
}
```
For **fundamental types**, the const qualifier on a return type is simply ignored (your compiler may generate a warning). <br>
For other types, **return by value for constant variables is not a good practice** and it can interfere with compiler's optimization(**move semantics**) for non-const return by value. <br>

### contant variables over macros
- Macros cannot be scoped unlike constants as it is handled separately by preprocessor
- They don't have C++ syntax so it is difficult to debug them and it is difficult to inspect their value
```
void someFcn() {
// Even though gravity is defined inside this function
// the preprocessor will replace all subsequent occurrences of gravity in the rest of the file
#define gravity 9.8
}

void printGravity(double gravity) { // including this one, causing a compilation error
    std::cout << "gravity: " << gravity << '\n';
}
```
Use:
```
const int MAX_VALUE = 100;
```

## Multifile code
We declare them once in a central location and use them wherever needed. That way, if you ever need to change them, you only need to change them in one place. <br>
This can be well facilitate using **inline variables**.

## Literal contants
Literals are values that are **inserted directly into the code.** <br>
```
return 5;                     // 5 is an integer literal
bool myNameIsAlex { true };   // true is a boolean literal
double d { 3.4 };             // 3.4 is a double literal
std::cout << "Hello, world!"; // "Hello, world!" is a C-style string literal
```

### Literal suffixes
one can have literal suffixes like `f` to suggest the type of literal. `f` is used for a floating value. <br>
It is often used for **type deduction** too using auto keyword. <br>

This may cause warning <br>
```
float f { 4.1 }; // warning: 4.1 is a double literal, not a float literal
float f {4.1f} 	 //this works
```

### String Literals
- They are not fundamental to C++ and have a strange and complicated type that is hard to work with
- For this reasons they are known as **C-Style** strings
- They have null termination `'\0'`
- "Hello" has type `const char[6]` and not `const char[5]` due to null terminator

C-style string literals are const objects that are created at the start of the program and are guaranteed to **exist for the entirety of the program**.

## Numeral Systems
There are **4 main numeral systems** available in C++. In order of popularity, these are: 
1. decimal (base 10)
2. binary (base 2)
3. hexadecimal (base 16)
4. octal (base 8).

### Hexadecimal Literals
```
int x{ 0xF }; // 0x before the number means this is hexadecimal
```
**Binary Repesentation**
Because there are 16 different values for a hexadecimal digit, we can say that a **single hexadecimal digit encompasses 4 bits**. <br> **(00) is a byte**
```
32-bit integer : 0011 1010 0111 1111 1001 1000 0010 0110
hex value : 3A7F 9826
```

It is often used to represent memory addresses.

## Binary Literals 
```
bin = 0x0001; //before C++14
bin = 0b1;   //after C++14
```

### Digit separators
```
int bin { 0b1011'0010 };
long value { 2'132'673'462 };
```
separator can not occur before the first digit of the value:
```
int bin { 0b'1011'0010 };  // error: ' used before first digit of value
```

### Bitset
Doing output of binary literal in `std::cout`  a little difficult, we can use `biset` to store those literals and then output them:
```
std::bitset<8> bin1{ 0b1100'0101 };
```
C++ onwards std::format is also used:
```
std::cout << std::format("{:b}\n", 0b1010);  // C++20
```

## Constant Expressions
The **as-if** rule says that the compiler can modify a program however it likes in order to produce more optimized code, so long as those modifications do not affect a program’s “observable behavior” <br>

### Compile Time Evaluation
```
int x { 3 + 4 };
std::cout << x << '\n';
```

In the code above,  if not optimized compiler would have to **generate an executable that calculates** the result of `3 + 4`, if theis calculation is performed million times then it would lead to resource waster. <br>
To avoid this the compiler optimizes the `3+4` expression at the compile time itself and save the run time resource wastage. 
```
int x {7};
std::cout << x << '\n';
```
Although, this might make the compile time longer. These opimizations are one of the strong features of modern C++. 

### Constant Expressions

A constant expression contains on **compile time constants** and  **operators/functions** that support compile time evaluation. <br>

Examples of Compile time constants
1. Literals (e.g. ‘5’, ‘1.2’)
2. Constexpr variables
3. Const integral variables `const int x { 5 }`. We don't include **runtime constants** here : **const int x{value}**
5. Non-type template parameters
6. Enumerators 

**NOTE**: If you need runtime constant variables to be compile-time constants, define them as _constexpr variables_ instead. <br>

### Compile time vs run time const
**Compile Time constant**
```
const int c { 5 };           // 5 is a constant expression
const int d { c };           // c is a constant expression
const long e { c + 2 };      // c + 2 is a constant expression
```
Constant expressions **are always eligible for compile-time evaluation**, meaning they are more likely to be optimized at compile-time.
<br>
**Run time constant** <br>
```
int a { 5 };                 // 5 is a constant expression
double b { 1.2 + 3.4 };      // 1.2 + 3.4 is a constant expression

const int f { a };           // a is not a constant expression
const int g { a + 1 };       // a + 1 is not a constant expression
const long h { a + c };      // a + c is not a constant expression
const int i { getNumber() }; // getNumber() is not a constant expression
```
These may or may not have compile time optimization. <br>

NOTE: const Function parameters are also runtime-constants.

**Runtime constant optimization** <br>
```
int x { 7 };            // x is non-const
std::cout << x << '\n'; // x is a non-constant subexpression
```

A smart compiler might realize that `x` will always evaluate to `7` in this particular program and it will optimize this under as-if rule. So it will remove x variable completely and replace next line `x` with `7`.

```
std::cout << 7 << '\n';
```

Had it been ```const int x {7}```, the compiler would have optmized it anyway.

> Order of optimization for compiler is
> - Compile-time constant variables (always eligible to be optimized)
> - Runtime constant variables
> - Non-const variables (likely optimized in simple cases only)

### Debugging Issue
Due to variable removal in optimization, the variables are often skipped while debugging. <br>
But debugger these days have optimizations turned off.

## Constexpr Variables
In some cases it is difficult to to gues for a compiler if the expression is a run time or compiler time constant:
```
const int d { obj };        // not obvious whether this is a runtime or compile-time const
const int e { getValue() }; // not obvious whether this is a runtime or compile-time const
```

In order to help with this, we utilize compilers power to hint us with constant expression by using **constexpr keyword**. <br>

A constexpr keyword **must** always be initilized with constant expression. These statements would be evaluated at compile time<br>
```
constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
constexpr int something { sum };  // ok: sum is a constant expression
```
Where is doesn't work ?<br>
**Example 1:**
```
int age{};
std::cin >> age;
constexpr int myAge { age };      // compile error: age is not a constant expression
```
**Example 2:**
```
int five(){  return 5;}
constexpr int f { five() };       // compile error: return value of five() is not a constant
```
This will not work as five() is not a constant. To resolve this we need to make five() constexpr too.
```
constexpr int five(){  return 5;}
constexpr int f { five() };       // compile error: return value of five() is not a constant
```

## Const vs constexpr

For variables, 
- **const** means that the value of an object **cannot be changed** after initialization. 
- **constexpr** means that an object must have a value that is **known at compile-time**.

Constexpr variables are implicitly const. Const variables are not implicitly constexpr. <br>
**constexpr is not valid** for dynamic memory allocatiosn (including std::string, std::vector). <br>

NOTE: Function parameters can never be constexpr.

## Conditional Operator
Using constexpr for conditional operator : 
```
constexpr bool inBigClassroom { false };
constexpr int classSize { inBigClassroom ? 30 : 20 };
```

## Inline functions
Writing a simple function like min(x,y) and calling it can have several overheads like:
```
int min(int x, int y){
    return (x < y) ? x : y;
}

int main(){
    std::cout << min(5, 6) << '\n';
}
```
- CPU must store the address of the current instruction it is executing (so it knows where to return to later)
- + Along with the values of various CPU registers (so they can be restored upon returning)
- Then parameters x and y must be instantiated and then initialized
- Then the execution path has to jump to the code in the min() function
- When the function ends, the program has to jump back to the location of the function call
- The return value has to be copied so it can be output

This a lot of overhead for just executing a simple min(x,y) function.


### Earlier C++ Compilers
Earlier compilers handled **inline** keyword explicitly and user put inline keyword to let the compiler have an **option** to optimize the overhead or ignore it (in case lopps are there)
```
inline int min(int x, int y) // inline keyword means this function is an inline function
{
    return (x < y) ? x : y;
}
```

### Modern C++ Compilers
Modern C++ compilers are smart enough to decide if inline expansion would reduce function overhead or not by doing **inline expansion** and it is done automatically, thereby inline keyword is no longer used in modern C++. <br>

You would hardly see any difference in the instrctions set (tried in godbolt.org) for min(x,y) with and without inline.<br>

Most of the functions fall into inline expansion and only some don't. 
**Judging** <br>
If the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower.

### Harms of inline keyword
- Using inline to request inline expansion is a form of **premature optimization**, and misuse could actually harm performance
- The inline keyword is just a hint -- the compiler is completely **free to ignore** a request to inline a function
- **BEST PRACTICE** : Do not use the inline keyword to request inline expansion for your functions.

## Modern "inline" usage
In modern C++, the term inline has evolved to mean “multiple definitions are allowed”.
```
// pi.h
#ifndef PI_H
#define PI_H

inline double pi() { return 3.14159; };

inline std::mt19937 generate()
{
	std::random_device rd{};

	// Create seed_seq with clock and 7 random numbers from std::random_device
	std::seed_seq ss{
		static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),
			rd(), rd(), rd(), rd(), rd(), rd(), rd() };

	return std::mt19937{ ss };
}

#endif
```
```
//main.cpp:

#include "pi.h" // will include a copy of pi() here
#include <iostream>

double circumference(double radius); // forward declaration

int main(){
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```
```
//math.cpp

#include "pi.h" // will include a copy of pi() here

double circumference(double radius){
    return 2.0 * pi() * radius;
}
```
1.  In the code above, both main.cpp and math.cpp will have the copy of ```inline double pi() { return 3.14159; }```, but it will be de-duplicated by complier since it is put as an inline variable. <br>

2. Similar statement goes for std::mt19937 generate() random number **general purpose function**. <br>

3. They should generally be used in  **header-only libraries** <br>

**Why not make all functions inline and defined in a header file?**
Inline functions allow definitions in header file, if we do so for all the functions, then changes in the any of the function defition would need all the source file to be recompile which are including that header file.


## Constexpr functions
```
int greater(int x, int y){
    return (x > y ? x : y); // here's our expression
}

int main(){
    constexpr int x{ 5 };
    constexpr int y{ 6 };
    std::cout << greater(x, y) << " is greater!\n"; // will be evaluated at runtime

    return 0;
}
```

In the above code, despite the x and y being constexprm the function greater (x,y) becomes run time constant. <br>
In order to make it compile time constant, we need to make it constexpr too. <br>

```
constexpr int greater(int x, int y){
    return (x > y ? x : y); // here's our expression
}
```
NOTE : To be **eligible** for compile-time evaluation, a **function must have a constexpr return type**.

### Run-time Evaluation
```
constexpr int greater(int x, int y){
    return (x > y ? x : y);
}

int main(){
    int x{ 5 }; // not constexpr
    int y{ 6 }; // not constexpr

    std::cout << greater(x, y) << " is greater!\n"; // will be evaluated at runtime

    return 0;
}
```

In the above case, x and y are not const expressions yet we have kept greater() to be constexpr to make it available for constexpr variables too.

### Other non-eligible cases
```
constexpr int g { greater(5, 6) };              // case 1: always evaluated at compile-time
std::cout << g << " is greater!\n";

std::cout << greater(5, 6) << " is greater!\n"; // case 2: may be evaluated at either runtime or compile-time

int x{ 5 }; // not constexpr but value is known at compile-time
std::cout << greater(x, 6) << " is greater!\n"; // case 3: likely evaluated at runtime

std::cin >> x;
std::cout << greater(x, 6) << " is greater!\n"; // case 4: always evaluated at runtime
```
Thus, a constexpr function is better thought of as “**can be used in a constant expression**”, not “**will be evaluated at compile-time**”.

NOTE: Dependent constexpr functions should also evaluate at compile time.

### Forcing constexpr evaluation
The most common way to do this is to use the return value to initialize a constexpr variable.


## Consteval
In c++ 20 we have consteval which makes a function do compile time evaluation only, else it will show errors on it.
```
constexpr int g { greater(5, 6) };              // ok: will evaluate at compile-time
std::cout << g << '\n';

std::cout << greater(5, 6) << " is greater!\n"; // ok: will evaluate at compile-time

int x{ 5 }; // not constexpr
std::cout << greater(x, 6) << " is greater!\n"; // error: consteval functions must evaluate at compile-time
```

But issue with consteval is that unlike constexpr it is not open for run-time evaluation<br>
In order to do so, we have a a trick to make constexpr do consteval do partly and consteval partly:

```
consteval auto compileTime(auto value){
    return value;
}

constexpr int greater(int x, int y) // function is constexpr{
    return (x > y ? x : y);
}

int main(){
    std::cout << greater(5, 6) << '\n';              // may or may not execute at compile-time
    std::cout << compileTime(greater(5, 6)) << '\n'; // will execute at compile-time
}
```

## Implcit Inlining
Because constexpr functions may be evaluated at compile-time, the compiler must be able to see the full definition of the constexpr function at all points where the function is called. A forward declaration will not suffice, even if the actual **function definition appears** later in the same compilation unit. <br>

constexpr functions are often defined in **header files**, so they can be #included into any .cpp file that requires the full definition. <br>

To avoid such problems, constexpr and consteval functions **are implicitly inline**, which makes them exempt from the one-definition rule.

### Disadvantages of constexpr
1. They are difficult to debug as they cannot be inspected on runtime


## std::string

Keypoints:
- you can’t use assignment to assign a C-style string variable a new value
- if you copy a larger C-style string into the space allocated for a shorter C-style string, undefined behavior will result
- In modern C++, C-style string variables are best avoided
- String characters are **null-terminated**

std::string is not a fundamental data type, rather a class type.

### std::getline()
```
std::string name{};
std::getline(std::cin >> std::ws, name);
```

### string length
Two ways :
```
std::cout << name << " has " << name.length() << " characters\n";
std::cout << name << " has " << std::ssize(name) << " characters\n"; // C++ 20
```

### Disadvantages
1. Initializing a std::string is expensive : As you have to initilize character by character
2. Do not pass std::string by value : Again character by charater copying to initilize is done here making expensive operation

Exception in **return by value** <br>
In these cases of return by value you would give compiler oppurtunity to do **optimization via move semantics**.
1. A local variable of type std::string
```
std::string createString() {
    std::string message = "Hello, world!";
    return message;
}
```
2. A std::string that has been returned by value from a function call or operator
```
std::string concatenate(const std::string& str1, const std::string& str2) {
    return str1 + str2;
}
```
3. A std::string that is created as part of the return statement
```
std::string getMessage() {
    return "Hello, world!";
}
```
4. Returning by **const reference**
```
const std::string& getGreeting() {
    static std::string greeting = "Hello, world!";
    return greeting;
}
```

**HOW ?** <br>
`std::string` supports a capability called **move semantics**, which allows an **object that will be destroyed at the end of the function** to instead be returned by value without making a copy. <br>

**BEST PRACTICE**<br>
If returning a C-style string literal, use a `std::string_view` return type instead. <br>

## constexpr for strings
```
 constexpr std::string name{ "Alex"s }; // compile error
```
It is not supported

## std::string_view
### std::string disadvantages
```
void printString(std::string str) // str makes a copy of its initializer{
    std::cout << str << '\n';
}
std::string s{ "Hello, world!" }; // s makes a copy of its initializer
printString(s);
```

Lots of needless copying happening above for strings and expensive operation <br>

### std::string_view property
std::string_view provides **read-only access** to an existing string. <br>
```
void printString(std::string_view str) // str makes a copy of its initializer{
    std::cout << str << '\n';
}
std::string_view s{ "Hello, world!" }; // s makes a copy of its initializer
printString(s);
```
In the code above:
1. `s` has a read only access to to `"Hello, World!"` string without making copy initilization
2. similarly, `str` in `printString()` also has read access to `"Hello, World!"` without making copy
3. `string_view` views the object that already exists elsewhere and cannot modify that object
4. ** If the string being viewed is modified** or destroyed while the view is still being used, unexpected or **undefined** behavior will result, also known as **dangling view**
```
 std::string message = "Hello, world!";
 std::string_view view{ message };

 std::cout << "View: " << view << std::endl;
 message = "Modified message"; // Modifying the original string
 std::cout << "View after modification: " << view << std::endl; //undefined behaviour

//Revalidate
view = message;
```
output
```
View: Hello, world!
View after modification: ╬àorld! //undefined
```
After modification, of the string std::string_view does not own the data it references, hence undefined behaviour. <br>
OR - OTHER EXAMPLE
```
std::string getName(){
    std::string s { "Alex" };
    return s;
}

int main(){
  std::string_view name { getName() }; // name initialized with return value of function
  std::cout << name << '\n'; // undefined behavior
}
```
`s` is destroyed at the end of the scope. <br>

OR <br>
Initializing with string literal, as it is temporary
```
using namespace std::string_literals;
std::string_view name { "Alex"s }; // "Alex"s creates a temporary std::string
std::cout << name << '\n'; // undefined behavior
```
OR<br>
returning string to string_view by value :
```
std::string_view getBoolName(bool b)
{
    std::string t { "true" };  // local variable
    std::string f { "false" }; // local variable

    if (b)
        return t;  // return a std::string_view viewing t
	//return "true"; Use "C Style Strings" instead

    return f; // return a std::string_view viewing f
} // t and f are destroyed at the end of the function
```
In the code above, `t` is destroyed by the end of the function, hence string_view would become invalid too. <br>
Use C-Style strings instead as they exist throughout the entire program. <br>

std::string_view parameter will accept arguments of type `C-style string`, a `std::string`, or `std::string_view`

**OK Usage of string_view** <br>
```
std::string_view firstAlphabetical(std::string_view s1, std::string_view s2){
    return s1 < s2 ? s1: s2; // uses operator?: (the conditional operator)
}

int main(){
    std::string a { "World" };
    std::string b { "Hello" };
    std::cout << firstAlphabetical(a, b) << '\n'; // prints "Hello"
}
```
Since, `a` and `b` are not getting destroyed which string_vew processes them in the functio, hence it will be okay.




 ### string_view to string
 1. We can directly inialize string with string_view  : `std::string s{ sv };`
 2. cast string_view to string : `static_cast<std::string>(sv)`

### string_view and constexpr
Contrary to support with std::string(due to dunamic allocation), std::string_view has full support of constexpr
```
constexpr std::string_view s{ "Hello, world!" }; // s is a string symbolic constant
std::cout << s << '\n'; // s will be replaced with "Hello, world!" at compile-time
```

### string_view vs string&
For function parameter, always prefer `string_view` over `string&`

### Modifiying with string_view
The modification fucntions does not affect the original string here. We can use `remove_prefix()` and `remove_suffix()`
```
std::string_view str{ "Peach" };
std::cout << str << '\n'; 

// Remove 1 character from the left side of the view
str.remove_prefix(1);
std::cout << str << '\n'; //prints "each"

// Remove 2 characters from the right side of the view
str.remove_suffix(2);
std::cout << str << '\n'; //prints "ea"
```

### null termination
A C-style string literal and a std::string are always null-terminated. <br>
A std::string_view may or may not be null-terminated.


# Operators

## Precedence and associativity
How is BODMAS followed in C++:

### Operator Precedence
Operators with a higher precedence level are grouped with operands first. <br>
**multiplication and division (precedence level 5)** have a higher precedence level than **addition and subtraction (precedence level 6)**. Thus, multiplication and division will be grouped with operands before addition and subtraction. In other words, `4 + 2 * 3` will be grouped as `4 + (2 * 3)`.

### Operator Associativity
For e.g. `7 - 4 - 1` <br>

operator’s associativity tells the compiler whether to evaluate the operators from left to right or from right to left. Subtraction has precedence level 6, and the operators in precedence level 6 have an associativity of left to right.<br>
So this expression is grouped from left to right: `(7 - 4) - 1`.

### General Usage
It's difficult to remember the precedence and associativity from the tables, so the developer should make the operation explicit by put the paranthesis by himself/herself.

```
int getValue(){
        int x{};
    std::cin >> x;
    return x;
}

void printCalculation(int x, int y, int z){
    std::cout << x + (y * z);
}

int main(){
    printCalculation(getValue(), getValue(), getValue()); 
    return 0;
}
```
In the above function call `printCalculation(getValue(), getValue(), getValue());`, the values are entered in `printCalculation(3,2,1);` as arguments evaluate in **right-to-left** order.


## Arithmatic Operators
### Unary
in `+5` and `-5` , `+` and `-` are unary operators

### Bianry
`+`,`-`, `/`, `*`, `%`

### Integer and Floating Point division
If either of the operads is a floating point, then the output is also a floating point: <br>
`7.0 / 4 = 1.75`, `7 / 4.0 = 1.75`, and `7.0 / 4.0 = 1.75` <br>
<br>
If both are integers then they output integer only: <br>
`7 / 4 = 1`

### Utilising static_cast 
If we have input as integers only, we can do static_cast to convert them to floating point in order to assist the floating point division.

```
constexpr int x{ 7 };
constexpr int y{ 4 };

std::cout << "int / int = " << x / y << '\n';
std::cout << "double / int = " << static_cast<double>(x) / y << '\n';
std::cout << "int / double = " << x / static_cast<double>(y) << '\n';
std::cout << "double / double = " << static_cast<double>(x) / static_cast<double>(y) << '\n';
```


## Remainder Operator
Remainder takes the sign of the first operand.

Example 1
```
Enter an integer: 6
Enter another integer: -4
The remainder is: 2
```
Example 2
```
Enter an integer: -6
Enter another integer: 4
The remainder is: -2
```

## Exponent Operator
It exists in `cmath` library <br>
```
std::pow(3.0, 4.0)
```

## Increment/decrement operators

### Pre-increment
```
int y { ++x };
```
In the code above steps are:
1. `x` is incremented
2. `x` is evaluated
3. Evaluated `x` is assigned to `y`

### Post increment
```
int x { 5 };
int y { x++ };
```
1. A temporary copy of `x` is made that starts with the same value as `x(5)`
2. Then the actual `x` is incremented from `5` to `6`
3. Then the copy of `x` (which still has value `5`) is returned and assigned to `y`
4. Temporary copy is discarded.

Post-increment involves a lot of steps hence it is not same in performace compared to pre-increment.

## When to use?
Whereever both can be used, prefer pre increment

## Side Effects
A function and expression has a side effect when it have observable effect beyong returning value.

```
++x
```
In the code above, apart from returning increment value, the value of x also gets affected which is a side effect

```
std::cout << x;
```
In the code above, apart from output the value to <<, it shows the value on console to which is a side effect.

### Order of evaluation
```
int x { 5 };
int value{ add(x, ++x) };
```
 - If the left argument is evaluated first, this becomes a call to add(5, 6), which equals 11.
 -  If the right argument is evaluated first, this becomes a call to add(6, 6), which equals 12!
 -   At the end it all depends on the compiler.
 -   Visual Studio and GCC evaluate this as 2 + 2, and Clang evaluates it as 1 + 2! This is due to differences in when the compilers apply the side effect of incrementing x.

## Comma Operator
**Dangerous usage** <br>

```
int x{ 1 };
int y{ 2 };
std::cout << (++x, ++y) << '\n'; // increment x and y, evaluates to the right operand
```
In the code above, x is evaluated first and then y, but only ye is assgiened to z.

```
z = (a, b);
```
Similary above, b is assigned to z.

## Relational Operators
### Comparing equal floating values
```
constexpr double d1{ 100.0 - 99.99 }; // should equal 0.01 mathematically
constexpr double d2{ 10.0 - 9.99 }; // should equal 0.01 mathematically

if (d1 == d2)
        std::cout << "d1 == d2" << '\n';
    else if (d1 > d2)
        std::cout << "d1 > d2" << '\n';
    else if (d1 < d2)
        std::cout << "d1 < d2" << '\n';
```
OUTPUT
```
d1 > d2
```
Even though both are equal but but they wouldn't be equal as floating values **not precise and rounding errors are always involved**. <br>

In non-equal operands, they produce reliable answer, but in case of equal operands, their answer may not be reliable <br>

### == and != for floating values
It should be generally avoiding for floating values as the answers are generally unreliablr.

**Exception** <br>
In case of comparing literals, it will work well. literal has some specific and unique representation in memory.
```
if (someFcn() == 0.0) // okay if someFcn() returns 0.0 as a literal only

constexpr double gravity { 9.8 }
if (gravity == 9.8) // okay if gravity was initialized with a literal
```
 ### Resolution  - epsilon
 We can use some **tolerance** value <br>

 Using **epsilon** which means close enough<br>
 ```
bool approximatelyEqualAbs(double a, double b, double absEpsilon){
        return std::abs(a - b) <= absEpsilon;
}

int main(){
    double a = 1.5;
    double b = 1.55;
    double epsilon = 0.1;
}
```
`std::abs(a - b) <= absEpsilon` checks if the distance between a and b is less than or equal to whatever epsilon value representing “close enough” was passed in.

### Reslution - Knuth's algorithm
```
bool approximatelyEqualRel(double a, double b, double relEpsilon){
	return (std::abs(a - b) <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}
```
Explaination: <br>
The algorithm chooses the larger of a and b (as a rough indicator of the overall magnitude of the numbers), and then multiplies it by relEpsilon. In this function, relEpsilon represents a percentage. For example, if we want to say “close enough” means a and b are within 1% of the larger of a and b, we pass in an relEpsilon of 0.01 (1% = 1/100 = 0.01). The value for relEpsilon can be adjusted to whatever is most appropriate for the circumstances (e.g. an epsilon of 0.002 means within 0.2%). <br>

## Logical Operators

### Not operator
```
int x{ 5 };
int y{ 7 };

(!x > y)
```
Logical NOT operator has higher precedence than the greater than operator, the expression `! x > y` actually evaluates as `(!x) > y`. Since `x` is `5`, `!x` evaluates to `0`.

### && Operator
**Short circuit evaluation** <br>
If the left operand evaluates to false, logical AND knows it must return false regardless of whether the right operand evaluates to true or false. In this case, the logical AND operator will go ahead and return false **immediately without even evaluating the right operand**! <br>
```
if (x == 1 && ++y == 2)
    // do something
```
Operators with side effect like `++y` should not be used for compound expressions.

**RESOLUTION** <br>
If you overload these operators to make them work with your own types, those overloaded operators will not perform short-circuit evaluation.

### && vs ||
&& operator has high precedence over || <br>

In an example of `value1 || value2 && value3`, because logical AND has higher precedence, this evaluates as `value1 || (value2 && value3)`, not `(value1 || value2) && value3`.

**RESOLUTION**
rather than writing `value1 && value2 || value3 && value4`, it is better to write `(value1 && value2) || (value3 && value4)`.

### XOR
We can use `!=` operator instead<br>

Extension : <br>
```
if (a != b != c) ... // a XOR b XOR c, assuming a, b, and c are bool
```

## Alternative Operators 
- `&&` - `and`
- `||` - 'or'
- '!' - 'not'

```
std::cout << !a && (b || c);
std::cout << not a and (b or c);
```

# Bit Manipulation
## Bit sequencing
```
00000101  Bit sequence
76543210  Bit position
```
Bit sequencing starts from right to left

## std::bitset
4 member functions:
1. test()
2. set()
3. reset()
4. flip()

```
std::bitset<8> bits{ 0b0000'0101 }
std::cout << "All the bits: " << bits<< '\n';

//output
All the bits: 00001101
```

## Encoding bitset
```
[[maybe_unused]] constexpr int  isHungry   { 0 };
[[maybe_unused]] constexpr int  isSad      { 1 };
[[maybe_unused]] constexpr int  isMad      { 2 };
[[maybe_unused]] constexpr int  isHappy    { 3 };
[[maybe_unused]] constexpr int  isLaughing { 4 };
[[maybe_unused]] constexpr int  isAsleep   { 5 };
[[maybe_unused]] constexpr int  isDead     { 6 };
[[maybe_unused]] constexpr int  isCrying   { 7 };

std::bitset<8> me{ 0b0000'0101 }; // we need 8 bits, start with bit pattern 0000 0101
me.set(isHappy);      // set bit position 3 to 1 (now we have 0000 1101)
me.flip(isLaughing);  // flip bit 4 (now we have 0001 1101)
me.reset(isLaughing); // set bit 4 back to 0 (now we have 0000 1101)
```

## Bitwise Operators
1. x << y	all bits in x shifted left y bits
2. x >> y	all bits in x shifted right y bits
3. ~x	all bits in x flipped
4. x & y	each bit in x AND each bit in y
5. x | y	each bit in x OR each bit in y
6. x ^ y	each bit in x XOR each bit in y

## Bitwise assignment operators
1. x <<= y	Shift x left by y bits
2. x >>= y	Shift x right by y bits
3. x |= y	Assign x | y to x
4. x &= y	Assign x & y to x
5. x ^= y	Assign x ^ y to x


### Rightshift
**Operator**
```
std::bitset<4> x { 0b1100 };
std::cout << (x >> 1) << '\n'; // shift right by 1, yielding 0110
```
**Assignment Operator**
```
std::bitset<4> bits { 0b0100 };
bits >>= 1;
```


### NOT
```
std::cout << ~std::bitset<4>{ 0b0100 }
```

### OR
```
std::cout << (std::bitset<4>{ 0b0101 } | std::bitset<4>{ 0b0110 })
```

### AND
```
std::cout << (std::bitset<4>{ 0b0101 } & std::bitset<4>{ 0b0110 }) << '\n';
```

## Bit Masking
- Bitwise operators don’t know how to work with bit positions. Instead they work with bit masks.
- A bit mask is a predefined set of bits that is used to select which specific bits will be modified by subsequent operations.
- A best practice is to **give your bit masks useful names** as a way to document the meaning of your bit flags

### In C++ 14
```
constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7
```
### In C++ 11 and before
We use hex digits
```
constexpr std::uint8_t mask6{ 0x40 }; // hex for 0100 0000
constexpr std::uint8_t mask7{ 0x80 }; // hex for 1000 0000
```
Easier version :
```
constexpr std::uint8_t mask6{ 1 << 6 }; // 0100 0000
constexpr std::uint8_t mask7{ 1 << 7 }; // 1000 0000
```

### Testing on/off 

```
[[maybe_unused]] constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6
[[maybe_unused]] constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7

std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags

std::cout << "bit 0 is " << (static_cast<bool>(flags & mask0) ? "on\n" : "off\n");
std::cout << "bit 1 is " << (static_cast<bool>(flags & mask1) ? "on\n" : "off\n");
```

We use '&` between mask and bitset and then do `static_cast<bool>` on the result.


### Set bit
We use `OR` operator in this case
```
std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags
flags |= mask1; // turn on bit 1
```
### Resetting a bit
 ```
std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags
flags &= ~mask2; // turn off bit 2
```
### Flipping a bit
```
std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags
flags ^= mask2; // flip bit 2
```

### Usage 
Imagine a function taking 32 boolean parameters, so instead of passing 32 boolean parameters, one can use below instead
```
void someFunction(std::bitset<32> options);
```
and play with your arguments like this:
```
someFunction(option10 | option32);
```

### OpelGL Example
```
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000

glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the color and the depth buffer
```

## 2's Complement
- Signed integers are typically stored using a method known as **two’s complement**
- Positive signed numbers are represented in binary just like positive unsigned numbers (with the sign bit set to 0)
- Negative signed numbers are represented in binary as the bitwise inverse of the positive number, plus 1

```
First we figure out the binary representation for 5: 0000 0101
Then we invert all of the bits: 1111 1010
Then we add 1: 1111 1011
```

# Scope, Duration & Linkage

## Limit og Nesting
Keep the nesting level of your functions to 3 or less. If your function has a need for more nested levels, consider refactoring your function into sub-functions.

## Scoped vs gloabl function
```
void print() // this print() lives in the global namespace{ std::cout << " there\n"; }
namespace Foo{
	void print() // this print() lives in the Foo namespace	{ std::cout << "Hello";	}

	void printHelloThere()	{
		print();   // calls print() in Foo namespace
		::print(); // calls print() in global namespace
	}
}
```

## Forward Decl in namespace
Both forward declaration and definition shoudl be inside namespace.
```
namespace BasicMath{
    // function add() is part of namespace BasicMath
    int add(int x, int y);
}
```
```
#include "add.h"
namespace BasicMath{
    // define the function add() inside namespace BasicMath
    int add(int x, int y)    {
        return x + y;
    }
}
```
```
#include "add.h" // for BasicMath::add()
#include <iostream>

int main(){
    std::cout << BasicMath::add(4, 3) << '\n';
    return 0;
}
```

## Global Variables
Gloabl varaibles are have global namespace scope.

### Duration
They start even before the **main()** begins and end when main() ends. Due to their duration they are also called _static variables_ (local variables are called automatic variables).

### Initilization
They are 0 initilized by default unlike global variables.
```
int g_x;       // no explicit initializer (zero-initialized by default)
```

### Constant Global  Variables
Non-constant global variables should generally be avoided altogether.

## Name Shadowing
```
int main(){
int apples { 5 }; { // here's the outer block apples
	std::cout << apples << '\n'; // print value of outer block apples
        int apples{ 0 }; // define apples in the scope of the nested block
        apples = 10; // this assigns value 10 to nested block apples, not outer block apples
        std::cout << apples << '\n'; // print value of nested block apples
    }
    std::cout << apples << '\n'; // prints value of outer block apples
    return 0;
}
```
Here `apples{0}` is getting in the scope it gets initilized and it's he same apple which is assigned value `10`, until then out apple variable is shadowed by inner `apple` .<br>

**Shadowing of global variable** <br>
In the same way the global variables are shadowed by local variables. What's why we should always use **::** in order to indicate the global variable. <br>

**NOTE** : Avoid Variable Shadowing

## Linkage
Variables and functions have either internal or external linkage.

### Linkage for Variables
- Local variables in general have internal linkage
- A **non-const** global variable with **static** keyword have internal linkage
- **Const** or **constexpr** global variables have internal linkage by default. They don't need _static_ keyword - if used it will be _ignored_.

```
//a.cpp
const int x{ 10 };
// int x{ 10 }; //This failes the compilation as this is external linkage variable
int main(){
	std::cout << x;
}
```

```
//b.cpp
int x {5};
```

The above code compilation succeeds as const int x is an internal linkage.


### Internal Linkage for functions
Functions by default have external linkage, but can be made internal linkage with **static keyword**. <br>

```
//a.cpp
int add(int x, int y){
	return x + y;
}
```
```
//b.cpp
static int add(int x, int y){
	return x + y;
}

int main()
{
}
```

The above code would now compile has static added keyword is not exposed to linker and according to linker one one definition of global `add()` function exists. <br>

There is no violation of ODR with internal objects.

### static vs unnamedspace
static keyword is not much for internal linkage, instead unnamed space is prefferred over it anytime for giver variety of identifiers internal linkage.

## External Linkage
 External linkage are truly “global” in that they can be used anywhere in your program!

```
//a.h
extern int x;
```
```
//a.cpp
int x {10};
```

```
#include "a.h"
//b.cpp
int main(){
   std::cout << x;
}
```

OUTPUT
```
10
// Output for the code above would be 10 from x.
// In order to access x you need to access the forward declation of x in a.h
```

### Functions External Linkage
Functions have external linkage by default. In order to use then you should have forward declared in some header and included that header in your usge file.

### Extern Keyword
Variables with external linkage are called external variables hence **extern keyword**.

Two meanings:
- give this variable external linkage
- this is a forward declaration for an external variable that is defined somewhere else

- **Non constant**  variables are external by default, for them **extern keyword is not required**, if put, it would be ignored
- Even **const** global variables which have internal linkage can be exposed to linker using **extern** keyword. But it is useless to do so. 
- Same goes for **constexpr** keyword variables. But it is useless to do so.

```
int g_x { 2 }; // non-constant globals are external by default

extern const int g_y { 3 }; // const globals can be defined as extern, making them external
extern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is pretty useless, see the warning in the next section)
```

## (non-const) global variables are evil
**BEST PRACTICE** : Avoid global variables.

Reasons:
1. Their values can be changed by any function that is called, and there is no easy way for the programmer to know that this will happen
2. It is difficult to debug where the variable value got changed
3. It makes code less modular

### Initialization
- Gloabl variables are initialized **even before the main** function
- **Phase 1** : static initialization - gloabl variables with constant expressions are initialized first `int x {5}`
- **Phase 2** : dynamic initialization - global variables with non-constexpr initializers are initialized. 
```
int init(){
    return 5;
}

int g_something{ init() }; // non-constexpr initialization
```
- Within a single file, for each phase, global variables are generally initialized in order of definition

### Best usage
- In case of **loggers**. It probably makes sense to define this as a global, because you’re likely to only have one log in a program and it will likely be used everywhere in your program. The `std::cout` and `std::cin` objects are implemented as global variables as well.
- If using a global variables otherwise, then put them under namespace
- Try to use them via passing argements


```
namespace constants{
    constexpr double gravity { 9.8 }; // has internal linkage, is accessible only within this file
}

double getGravity() // has external linkage, can be accessed by other files
{
    // We could add logic here if needed later
    // or change the implementation transparently to the callers
    return constants::gravity;
}
```

## Sharing global costants
It is generally helpful for constants like _Avogadro’s number_ or _gravity coefficient_ .<br>

### Method 1 - constexpr
Steps to use them:
1. **Create a header file** to hold these constants
2. Inside this header file, define a **namespace** (discussed in lesson 7.2 -- User-defined namespaces and the scope resolution operator)
3. Add all your constants inside the **namespace** (make sure they’re constexpr)
4. **#include** the header file wherever you need it

```
// define your own namespace to hold constants
namespace constants{
    // constants have internal linkage by default
    constexpr double pi { 3.14159 };
    constexpr double avogadro { 6.0221413e23 };
    constexpr double myGravity { 9.2 }; // m/s^2 -- gravity is light on this planet
    }
#endif
```

### Downsides to above method 
1.Since constant gloabl variables have insternal linkage that means each file they are included **will have their own copy**
2. Changing value of any one of the constant  would cause recompilation of all  the file that include the header
3. Although compiler optimizes by replacing the variable with values instead, but it might fail for large size constants.

### Method 2 - const
1. One way to avoid these problems is by turning these constants into external variables,  we can then have a single variable (initialized once) that is shared across all files.
2. We’ll define the constants in a .cpp file (to ensure the definitions only exist in one place), and put forward declarations in the header
3. We **use const instead of constexpr** in this method because constexpr variables can’t be forward declared
**constants.h**
```
namespace constants{
     extern const double pi;
}
```
**constants.cpp**
```

#include "constants.h"
namespace constants{
    extern const double pi { 3.14159 };
}
```
**main.cpp**
```
#include "constants.h" // include all the forward declarations
int main(){
     std::cout << "The circumference is: " << 2 *  constants::pi << '\n';
}
```

Now , Any changes made to constants.cpp will require recompiling only `constants.cpp`.

**Downside of this method** <br>
1. n other files, the **compiler will only see the forward declaration**, which doesn’t define a constant value (and must be resolved by the linker). This means in other files, these are treated as **runtime constant** values, not compile-time constants
2. Second, because compile-time constants can typically be optimized more than runtime constants, the compiler may **not be able to optimize** these as much


### Method 3 - inline
 These are variables that can have more than one definition, so long as those definitions are identical.

 ```
#ifndef CONSTANTS_H
#define CONSTANTS_H

// define your own namespace to hold constants
namespace constants
{
    inline constexpr double pi { 3.14159 }; // note: now inline constexpr
    inline constexpr double avogadro { 6.0221413e23 };
    inline constexpr double myGravity { 9.2 }; // m/s^2 -- gravity is light on this planet
    // ... other related constants
}
#endif
```

But it works same as Method 1 and this method does retain the downside of requiring every file that includes the constants header be recompiled if any constant value is changed.

## Static Local Variables
1. Variable is now created at the **start** of the program, and **destroyed** at the end of the program
2. static variable will **retain its value** even after it goes out of scope

### Initialization
1. Static local variables that are **zero initialized** `static int s_value` or have a **constexpr initializer** `static int s_value{ 1 }` can be initialized at **program start** 
2. Static local variables that have **no initializer** or a **non-constexpr initializer** are zero-initialized at **program start**
3. Static local variables with a **non-constexpr initializer** are **reinitialized** the first time the variable **definition is encountered**

NOTE: Program start here means after main function.

### Working
```
#include <iostream>

struct Int
{
	Int() = default;

	Int(int b) { a = b;}

	Int(const Int& obj) { a = obj.a; }

	int a = 0;
};


void myFunction() {
	// calls Int() = default;
	// calls int a = 0;
	// Called again 2 more times
	Int obj1;

	// calls Int(const Int& obj)
	// int a = 0;
	// Called only once and it retains its value as it is skipped in subsequent calls
	static Int obj2 = obj1;

}

int main() {
	myFunction(); // Output: Count in myFunction: 0
	myFunction(); // Output: Count in myFunction: 1
	myFunction(); // Output: Count in myFunction: 2
	return 0;
}
```

### Usage
1. It is very well used for unique ID generation
2. They offer benefit of global variables but limit its access to a scope


### Dont's
Don't alter your code flow like this
```
int getInteger(){
	static bool s_isFirstCall{ true };

	if (s_isFirstCall)	{
		std::cout << "Enter an integer: ";
		s_isFirstCall = false;
	}
	else	{
		std::cout << "Enter another integer: ";
	}

	int i{};
	std::cin >> i;
	return i;
}

int main(){
	int a{ getInteger() };
	int b{ getInteger() };
	std::cout << a << " + " << b << " = " << (a + b) << '\n';
	return 0;
}
```

- In the code above, the two calls of g**etInteger() are behaving differently**
- So **don't** use static variables to **change the code flow**
- Static local variables should only be used if in your entire program and in the foreseeable future of your program, **the variable is unique**

## Summary
[Check Summary here](https://www.learncpp.com/cpp-tutorial/scope-duration-and-linkage-summary/)

## Declarations and Directives

### Declarations
```
int main(){
   using std::cout; // this using declaration tells the compiler that cout should resolve to std::cout
   cout << "Hello world!\n"; // so no std:: prefix is needed here!

   return 0;
} // the using declaration expires at the end of the current scope
```

For avoid to write `std::` in front of cout everytime within a scope, we can use decalrations like using `std::cout` and its validity would be there till scope end.

### Directives

Or we can use ```using namespace std;:
```
int main(){
   using namespace std; // this using directive tells the compiler to import all names from namespace std into the current namespace without qualification
   cout << "Hello world!\n"; // so no std:: prefix is needed here

   return 0;
}
```

## Unnamed namespaces
```
namespace { // unnamed namespace
    void doSomething() { // can only be accessed in this file
        std::cout << "v1\n";
    }
}

int main(){
    doSomething(); // we can call doSomething() without a namespace prefix
    return 0;
}
```
- All content declared in an unnamed namespace is treated as if it is part of the parent namespace.
- But the other effect of unnamed namespaces is that all identifiers inside an unnamed namespace are treated as if they have **internal linkage**

## Inline namespaces
This is done to create different **versions of functions** while keeping the same function name.
```
inline namespace V1 {// declare an inline namespace named V1 - default
    void doSomething()  {
        std::cout << "V1\n";
    }
}

namespace V2 {// declare a normal namespace named V2
    void doSomething() {
        std::cout << "V2\n";
    }
}

int main(){
    V1::doSomething(); // calls the V1 version of doSomething()
    V2::doSomething(); // calls the V2 version of doSomething()
    doSomething(); // calls the inline version of doSomething() (which is V1) - default
}
```
ALternatively, if you want to use V2 as default option then make it inline instead.


# Control Flow

## if else statement
Always put blocks around statements under if to make it less error prone:
```
if (age >= minDrinkingAge)
    addBeerToCart();
```
OR do this:
```
if (age >= minDrinkingAge) purchaseBeer();
```
## null statement
For doing nothing under a condition
```
if (x > 10)
    ; // this is a null statement
```
**More details** <br>
```
if (nuclearCodesActivated());
    blowUpTheWorld();
```
The above code can be modified as :
```
if (nuclearCodesActivated())
    ; // the semicolon acts as a null statement
blowUpTheWorld(); // and this line always gets executed!
```

## operator = in condition
```
if (x = 0) // oops, we used an assignment here instead of a test for equality
        std::cout << "You entered 0\n";
```
- `x = 0` first assigns the value `0` to `x`, then evaluates to the value of `x`, which is now `0`, which is Boolean false
- Since the conditional is always false, the else statement always executes

## constexpr if statement
```
int main(){
	constexpr double gravity{ 9.8 };

	if constexpr (gravity == 9.8) // now using constexpr if
		std::cout << "Gravity is normal.\n";
	else
		std::cout << "We are not on Earth.\n";
}
```
1. The conditional of a constexpr-if-statement will be evaluated at compile-time.
2. If the constexpr conditional evaluates to true, the entire if-else will be replaced by the true-statement
3. f the constexpr conditional evaluates to false, the entire if-else will be replaced by the false-statement

## switch statements
- Compared to the original if statement, the switch statement has the advantage of only **evaluating the expression once** (making it more efficient)
- The one restriction is that the condition must evaluate to an **integral type** or **enumerated type**
- Expressions that evaluate to floating point types, strings, and most other non-integral types may not be used here
- Without `break` or `return` statement, all the statements are executed leading to fallthrough


### fallthrough
- Without the `break` or `return` statement the compiler generates warning
- In this case one can use `[[fallthrough]]` statement to make the fallthrough intentional so that no warning is generated

```
switch (2)
{
	case 1:
	  std::cout << 1 << '\n';
	  break;
	case 2:
	  std::cout << 2 << '\n'; // Execution begins here
	  [[fallthrough]]; // intentional fallthrough -- note the semicolon to indicate the null statement
	case 3:
	  std::cout << 3 << '\n'; // This is also executed
break;
} 
```

### Scoping
```
switch (1)
{
case 1: // does not create an implicit block
    foo(); // this is part of the switch scope, not an implicit block to case 1
    break; // this is part of the switch scope, not an implicit block to case 1
default:
    std::cout << "default case\n";
    break;
}
```
All the statements after case labels are considered scoped inside implcitly.


## While loop
**Doing something every n iteration** <br>
We can use `%` operator to do so, like we have used `if (count % 10 == 0)` in the example below:      
```
#include <iostream>

// Iterate through every number between 1 and 50
int main()
{
    int count{ 1 };
    while (count <= 50)    {
        // print the number (pad numbers under 10 with a leading 0 for formatting purposes)
        if (count < 10)        {
            std::cout << '0';
        }

        // if the loop variable is divisible by 10, print a newline
        if (count % 10 == 0)        {
            std::cout << '\n';
        }
        // increment the loop counter
        ++count;
    }
    return 0;
}
```

## For loops
Types are:
1. for statement
2. range based for loop

```
for (init-statement; condition; end-expression)
   statement;
```
Equivalent while statement:
```
{ // note the block here
    init-statement; // used to define variables used in the loop
    while (condition)
    {
        statement; 
        end-expression; // used to modify the loop variable prior to reassessment of the condition
    }
} // variables defined inside the loop go out of scope here
```
### Continue statement
It is used to skip the further steps in an iteration and instead move to next iteration
```
int main(){
    for (int count{ 0 }; count < 10; ++count)    {
        // if the number is divisible by 4, skip this iteration
        if ((count % 4) == 0)
            continue; // go to next iteration

        // If the number is not divisible by 4, keep going
        std::cout << count << '\n';
    }

    return 0;
}
```
### Early returns
Use return, break and continue inside a loop judiciousouly as they can are not easy to read while goin throug a code.

## exit and abort
### std::exit() of main
A normal program termination happens in std::exit. Steps are:
- First, objects with static storage duration are destroyed
- Then some other miscellaneous file cleanup is done if any files were used
- Finally, control is returned back to the OS, with the argument passed to std::exit() used as the status code

### std::exit explicit call
In this case, calling `std::exit()` explicitly: `std::exit()` **does not clean up any local variables** (either in the current function, or in functions up the call stack). Because of this, it’s generally better to **avoid** calling std::exit().

## cleanup() solution
- One can adde `cleanup()` function before the `std::exit` for clean exit
- Use `std::atexit()` which allows you to specify a function that will automatically be called on program termination via `std::exit()`

```
void cleanup(){
    // code here to do any kind of cleanup required
    std::cout << "cleanup!\n";
}

int main(){
    // register cleanup() to be called automatically when std::exit() is called
    std::atexit(cleanup); // note: we use cleanup rather than cleanup() since we're not making a function call to cleanup() right now

    std::cout << 1 << '\n';

    std::exit(0); // terminate and return status code 0 to operating system

    // The following statements never execute
    std::cout << 2 << '\n';

    return 0;
}
```
you can register multiple cleanup functions using `std::atexit()` if you want, and they will be called in reverse order of registration (the last one registered will be called first).

### exit for threads
- Calling std::exit() can cause your program to crash (because the thread calling std::exit() will cleanup static objects that may still be accessed by other threads)
- So we have `std::quick_exit()` and `std::at_quick_exit()` for this


### std::abort
- It is generally called in case of runtime abnormal situation like zero divide by zero
- It too doesn't do any cleanup

### std::terminate()
It is implicitly called in case of exceptions although it can be called explicitly too


# Error Handling
## Unit Testing
### Basic way of unit testing
```
bool isLowerVowel(char c){
    switch (c)    {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        return true;
    default:
        return false;
    }
}

// returns the number of the test that failed, or 0 if all tests passed
int testVowel(){
    if (!isLowerVowel('a')) return 1;
    if (isLowerVowel('q')) return 2;
    return 0;
}

int main(){
    int result { testVowel() };
    if (result != 0)
        std::cout << "testVowel() test " << result << " failed.\n";
    else
        std::cout << "testVowel() tests passed.\n";
    return 0;
}
```
### Using assert
```
#include <cassert> // for assert
#include <cstdlib> // for std::abort
#include <iostream>

bool isLowerVowel(char c){
    switch (c)    {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        return true;
    default:
        return false;
    }
}

// Program will halt on any failed test case
int testVowel(){
#ifdef NDEBUG
    std::cerr << "Tests run with NDEBUG defined (asserts compiled out)";
    std::abort();
#endif
    assert(isLowerVowel('a'));
    assert(isLowerVowel('e'));
    assert(isLowerVowel('i'));
    assert(isLowerVowel('o'));
    assert(isLowerVowel('u'));
    assert(!isLowerVowel('b'));
    assert(!isLowerVowel('q'));
    assert(!isLowerVowel('y'));
    assert(!isLowerVowel('z'));

    return 0;
}

int main(){
    testVowel();

    // If we reached here, all tests must have passed
    std::cout << "All tests succeeded\n";

    return 0;
}
```

## Code Coverage

1. **Code coverage** is used to describe how much of the source code of a program is executed while testing
2. The term **Statement coverage** refers to the percentage of statements in your code that have been exercised by your testing routines
3. **Branch coverage** refers to the percentage of branches that have been executed, each possible branch counted separately
4. **Loop Coverage** or **0,1,2 test** used for loops. you should ensure it works properly when it iterates 0 times, 1 time, and 2 times.If it works correctly for the 2-iteration case, it should work correctly for all iterations greater than 2.

## Fatal Errors
If the error is so bad that the program can not continue to operate properly, this is called a non-recoverable error (also called a fatal error). In such cases, the best thing to do is terminate the program. <br>
In such a case, a halt statement (such as std::exit())

## Exceptions
The basic idea is that when an error occurs, an exception is “thrown”. If the current function does not “catch” the error, the caller of the function has a chance to catch the error. If the caller does not catch the error, the caller’s caller has a chance to catch the error. The error progressively moves up the call stack until it is either caught and handled.

## cout vs cerr vs logging

## Input Validation

## Assertions
If the conditional expression evaluates to false, an error message is displayed and the program is terminated (via `std::abort` )

```
#include <cassert> // for assert()
#include <cmath> // for std::sqrt
#include <iostream>

double calculateTimeUntilObjectHitsGround(double initialHeight, double gravity){
  assert(gravity > 0.0); // The object won't reach the ground unless there is positive gravity.

  if (initialHeight <= 0.0)  {
    // The object is already on the ground. Or buried.
    return 0.0;
  }
  return std::sqrt((2.0 * initialHeight) / gravity);
}

int main(){
  std::cout << "Took " << calculateTimeUntilObjectHitsGround(100.0, -9.8) << " second(s)\n";
  return 0;
}
```

### Making it descriptive
```
assert(found && "Car could not be found in database");
```


## Assert vs Error Handling
1. Assertions : Use assertions to document cases that should be logically impossible
2. Error Handling : error handling is designed to gracefully handle cases that could happen

**Assert** <br>
- Many developers prefer that asserts are only active in debug builds. C++ comes with a way to turn off asserts in production code
-  If the macro NDEBUG is defined, the assert macro gets disabled
-  Some IDEs set NDEBUG by default as part of the project settings for release configurations

## static_assert
A static_assert is an assertion that is checked at **compile-time** rather than at runtime, with a failing static_assert causing a compile error. <br>

**Format**
```
static_assert(condition, diagnostic_message)
```

- static_assert is not compiled out in release builds
- static_assert can be placed anywhere in the code file (even in the global namespace).

Usages:
Usage 1:
```
constexpr int getValue() { return 42; }
static_assert(getValue() == 42, "getValue() must return 42");
```
Usage 2:
```
#include <type_traits>

template <typename T>
class MyClass {
    static_assert(std::is_integral<T>::value, "T must be an integral type");
    // Class implementation...
};
```
Usage 3:
```
template <typename T, typename U>
struct SameSize {
    static_assert(sizeof(T) == sizeof(U), "Types must have the same size");
    // SameSize implementation...
};
```


# Type conversions, aliases and deduction

## Why conversion ?
1. `3` might be stored as binary `0000 0000 0000 0000 0000 0000 0000 0011`
2. `3.0` might be stored as binary `0100 0000 0100 0000 0000 0000 0000 0000`

For this code:
```
float f{ 3 }; // initialize floating point variable with int 3
```

**Issue**: compiler can’t just copy the bits representing the int value 3 into the memory allocated for float variable f. <br>

Instead, it needs to **convert the integer value 3 to the equivalent floating point** value `3.0`, which can then be stored in the memory allocated for f.

## Implicit Type conversion
- Happens when one data type is required but different data type is supplied
- compiler will determine whether it can convert the value from the current type to the desired type
- If a valid conversion can be found, then the compiler will produce a new value of the desired type
- If the compiler can’t find an acceptable conversion, then the compilation will fail with a compile error


## Standard Conversions
Types are
- Numeric promotions 
- Numeric conversions 
- Arithmetic conversions 
- Other conversions 

## Zero conversion
- On architectures where int and long both have the same size and range
- The same sequence of bits is used to represent values of both types
- Therefore, **no actual conversion is needed** to convert a value between those types -- the value can simply be copied.

## Numeric Promotion
- It is a type conversion of certain narrower numeric types (such as a `char`) to certain wider numeric types (typically `int` or `double`)
- All numeric promotions are **value-preserving**, which means that the converted value will always be equal to the source value
- They are also **safe conversions**
- Compiler will **not issue a warning** when doing so.

### Print function:
```
void printInt(int x){
    std::cout << x << '\n';
}
```
- This function take `int` type input
- If type conversion would not have existed we would have to overload it for `short`, `char`, `unsigned char`, `signed char`, `unsigned short`, `wchar_t`, `char8_t`, `char16_t`, and `char32_t`

**Resolution** <br>
We can simply write function which takes `int` or `double` parameter type and the **same code can be called with**  arguments of types that can be numerically promoted to match the types of the function parameters. 

### Allowed Numeric Promotions
Only the conversions listed in these categories are considered to be numeric promotions:
1. integral promotions
2. floating point promotions

## Floating Point Promotions
A value of type `float` can be converted to a value of type `double`.
```
void printDouble(double d)
{
    std::cout << d << '\n';
}
```
- We can write a function that takes a double and then call it with either a `double` or a `float` value
- `float` literal `4.0f` is promoted into a `double`, so that the type of argument matches the type of the function parameter.


## Integral promotions
Rules:
- `signed char` or `signed short` can be converted to `int`
- `unsigned char`, `char8_t`, and `unsigned short` can be converted to `int`
- `bool` can be converted to `int`, with `false` becoming `0` and true becoming `1`.

```
short s{ 3 }; // there is no short literal suffix, so we'll use a variable for this one
printInt(s); // numeric promotion of short to int

printInt('a'); // numeric promotion of char to int
printInt(true); // numeric promotion of bool to int
```

NOTE : While integral promotion is value-preserving, it **does not necessarily preserve the signedness** (signed/unsigned) of the type.

## Numeric Conversions
Above we discussed _numeric promotions_ which is basically converting **narrow** numeric types **to** **wider** numeric types (typically `int` or `double`) <br>

**5 basic type** of numeric conversions: <br>
1. Converting an integral type to any other integral type - (Mostly demotion and not promotion)
```
short s = 3; // convert int to short
long l = 3; // convert int to long
char ch = s; // convert short to char------------------------shows warning
unsigned int u = 3; // convert int to unsigned int
```

2. Converting a floating point type to any other floating point type 
```
float f = 3.0; // convert double to float
long double ld = 3.0; // convert double to long double
```

3. Converting a floating point type to any integral type
```
int i = 3.5; // convert double to int------------------------shows warning
```

4. Converting an integral type to any floating point type
```
double d = 3; // convert int to double
```
5. Converting an integral type or a floating point type to a bool
```
bool b1 = 3; // convert int to bool------------------------shows warning
bool b2 = 3.0; // convert double to bool------------------------shows warning
```

NOTE : **Brace initilization** would not allow some of these conversion which are supported by copy inilization.

### Safety
Not all numeric conversions are safe and they can be put into **3 safety categories**

1. _Value-preserving conversions_ : Where there is no loss of data and are safe . **NO WARNINGS**<br>
For e.g. `int` to `long` and `short` to `double`

2. _Reinterpretive conversions_ : result may be outside the range of the source type and are potentially unsafe. **ERRORS**  <br>
For e.g. `signed int` to an `unsigned int`
```
int n1 { 5 };
unsigned int u1 { n1 }; // okay: will be converted to unsigned int 5 (value preserved)

int n2 { -5 };
unsigned int u2 { n2 }; // bad: will result in large integer outside range of signed int
```
In the 2nd example, since an unsigned int can’t represent negative numbers, the result will be a large integral value that is outside the range of a signed int.


3. _Lossy conversions_ : Some data is lost during conversion and they show **WARNINGS** <br>
For e.g. `double` to `int` OR `double` to `float`
```
int i = 3.0; // okay: will be converted to int value 3 (value preserved)
int j = 3.5; // data lost: will be converted to int value 3 (fractional value 0.5 lost)
```

NOTE : Althoug `int` to `double` is a safe conversion since `int` is a 4 bytes data type and `double` is a 8 bytes data type. But in some architectures where `int` is also 8 bytes it **might be a lossy conversion**. <br>

NOTE: In assembly language, for converting `int` to `float` value, the integer value is typically first extended or truncated to a specific size (e.g., 32-bit or 64-bit) if necessary, and then converted to a floating-point value. <br>

### Large Range to Small Range
converting large value to char may show some different output if large number is put:
```
int i{ 30000 };
char c = i; // Shows value as 48 - truncated value

int i2{ 30 };
char c2 = i2; // shows value 30
```
We’ve assigned a large integer to a variable with type char (that has range -128 to 127). This causes the char to overflow, and produces an unexpected result <br>

```
int i{ 2 };
short s = i; // convert from int to short
std::cout << s << '\n';

double d{ 0.1234 };
float f = d;
std::cout << f << '\n';
```
Converting from a larger integral or floating point type to a smaller type from the same family will generally work so long as the value fits in the range of the smaller type <br>

## Narrowing Conversions
Types of narrowed conversions:
1. From a floating point type to an integral type
2. From a floating point type to a narrower or lesser ranked floating point type
3. From an integral to a floating point type
4. From an integral type to another integral type that cannot represent all values of the original type

NOTE: Narrowing conversions should be avoided as much as possible, because they are potentially unsafe

## Safer Narrow Conversions - static_cast
It is the **implicit** narrowing conversions which are warned by the compiler, we can instead convert them into **explicit** narrow conversions to avoid warnings using `static_cast` <br>

```
void someFcn(int i) {}

int main(){
    double d{ 5.0 };
    someFcn(d); 			// Gives warnings
    someFcn(static_cast<int>(d)); 	// Doesn't give warnings
    return 0;
}
```

## Brace initilization
Brace initilization doesn't allow narrowing conversions.
```
int i { 3.5 }; // won't compile
```
Resolution: static_cast inside brace initilization
```
int i { static_cast<int>(d) };
```

## constexpr exceptions in conversions
Present day compilers are smart enough to tell you if the narrowing conversion would be safe or if the source value can fit in the destination value or not. This can be achieved via constexpr <br>
_When the source value of a narrowing conversion is constexpr, the specific value to be converted must be known to the compiler. In such cases, the compiler can perform the conversion itself, and then check whether the value was preserved._

### signed to unsigned
```
int n1{ 5 };   // note: constexpr
unsigned int u1{ n1 };  // okay: conversion is not narrowing due to exclusion clause
```
The code above gives error as in run time conversion from signed to unsigned data type may be unsafe.
```
constexpr int n1{ 5 };   // note: constexpr
unsigned int u1{ n1 };  // okay: conversion is not narrowing due to exclusion clause
```
But the code above compiles well as `n1` is made `constexpr`and it **decides at the compile time that the conversion is possible.**

### double to float
double to float is a narrowing conversion:
```
double d{ 0.1 }; 
float f{ d }; 
```
The code above would give **error** due to narrowing conversion in brace initilization.
```
constexpr double d{ 0.1 }; 
float f{ d };
```
but when doing constexpr the narrowing conversion is sorted out although with **warning**.

### avoiding static_cast
We can avoid static_cast if using constexpr
```
int n{ 5 };
double d{ n};
```
The code above gives error as we are using brace initilizer. How to avoid this error:
1. Copy initilization : worst solution as it is a implicit conversion 
```
int n{ 5 };
double d = n;
```

2. static_casting : It is for runtime conversion support
```
int n{ 5 };
double d { static_cast<double>(n)};
```

3. constexpr : for compile time resolution of conversion
```
constexpr int n{ 5 };
double d {n);
```

## Arithmatic Conversions
```
int x { 2 + 3.5 };
```
- Here both are of different type.
- In C++, certain operators require that their operands be of the same type
- If one of these operators is invoked with operands of different types, one or both of the operands will be **implicitly converted to matching types**

[source](https://www.learncpp.com/cpp-tutorial/arithmetic-conversions/)


## Type casting
Need:
```
int x { 10 };
int y { 4 };
double d = x / y; // does integer division, initializes d with value 2.0
```
How to tell the compiler that we want to have the floating division here to get output as `2.5` instead of `2.0`?  <br>

### Casting types
1. C-style casts
2. static casts
3. const casts---------------should be avoided
4. dynamic casts
5. reinterpret casts---------should be avoided


### C-Style casts
```
double d { (double)x / y }
//OR
double d { double(x) / y };
```
The problem can be solved like this as it was generally used in `C` language. <br>

**Disadvantages** :<br>
C-Syle cast handles mutliple kinds of cast like `static_cast`, `const_cast`, `reinterpret_cast` depending on the context and anytime and this is the undefined behaviour with the c-style cast. Inidividual casts are more defined.


### static_cast
It takes the value inside the paranthesis to convert it to the value inside the `<>` brackets.
```
double d { static_cast<double>(x) / y };
```
Usage: <br>
1. static_cast is best used to **convert one fundamental type** into another
2. To avoid warnings in narrowing conversions

## typedefs and typealiases

### using keyword
It is used to create aliases for for existing datatype. <br>
```
using Distance = double;
Distance milesToDestination{ 3.4 };
```
Type aliases are not type safe. <br>
If you need to use one or more type aliases across multiple files, they can be defined in a header file and #included into any code files that needs to use the definition: <br>
```
#ifndef MYTYPES_H
#define MYTYPES_H

    using Miles = long;
    using Speed = long;

#endif
```

### Strong typedefs
Some languages support the concept of a strong typedef (or strong type alias). A strong typedef actually creates a new type that has all the original properties of the original type, but the compiler will throw an error if you try to mix values of the aliased type. <br>
But there are quite a few 3rd party C++ libraries that implement strong typedef-like behavior. <br>

### Typedefs
A typedef (which is short for “type definition”) is an **older way** of creating an alias for a type.<br>
```
typedef double Distance
```
In typedef, type comes first and then the alias. <br>
Typedef sometimes can be confusing to work with for e.g.
```
typedef int (*FcnType)(double, char); // FcnType hard to find
using FcnType = int(*)(double, char); // FcnType easier to find
```
In the above typedef definition, the name of the new type (FcnType) is **buried in the middle of the definition**, whereas in the type alias, the name of the new type and the rest of the definition are separated by an equals sign.

### Usage 1 
Sometimes it is used for platform independent coding as char, short and int might have varying size in different architectures, we can utilize type-aliases in aliasing them to names like `int8_t`, `int16_t` and `int32_t` bases on architure used:
```
#ifdef INT_2_BYTES
  using int8_t = char;
  using int16_t = int;
  using int32_t = long;
#else
  using int8_t = char;
  using int16_t = short;
  using int32_t = int;
#endif
```
In fact, The fixed-width integer types (such as `std::int16_t` and `std::uint32_t`) are actually just type **aliases to various fundamental types.** To prove this :
```
std::int8_t x{ 97 }; // int8_t is usually a typedef for signed char
std::cout << x << '\n';
```
When you print an **8-bit fixed-width** integer using `std::cout`, you’re likely to get a character value. Because `std::int8_t` is typically a typedef for `signed char`, variable `x` will likely be defined as a `signed char`. And char types print their values as ASCII characters rather than as integer values.

## Usage 2
```
bool hasDuplicates(std::vector<std::pair<std::string, int>> pairlist){
    // some code here
    return false;
}
```
Using `std::vector<std::pair<std::string, int>>` everywhere would make our code cumbersome. Instead we can use type alias over here:
```
using VectPairSI = std::vector<std::pair<std::string, int>>;
```
To make the function easier to read now:
```
bool hasDuplicates(VectPairSI pairlist) {
    // some code here
    return false;
}
```

### Usage 3
We can use type alias to make the cod emore meaningful
```
int gradeTest();
```
Here return type is `int`, instead we can use a typealias to make the return type more meaningful
```
using TestScore = int;
TestScore gradeTest();
```
Creating a type alias just to document the return type of a single function isn’t worth it (**use a comment instead**).

### Usage 4
Code maintainance: <br>
For example, if you were using a `short` to hold a student’s ID number, but then later decided you needed a `long` instead. <br>
Then changing types becomes as simple as updating the type alias (e.g. from `using StudentId = short;` to using `StudentId = long;`

### Downside
Obscuring the type information can also be harmful to understanding how the type should be expected to work.

## Auto Keyword
Type deduction (also sometimes called type inference) is a feature that allows the compiler to deduce the type of an object from the object’s initializer.
```
auto d{ 5.0 }; // 5.0 is a double literal, so d will be type double
auto i{ 1 + 2 }; // 1 + 2 evaluates to an int, so i will be type int
auto x { i }; // i is an int, so x will be type int too
```
It **doesn't work** for uninitialized variables and void return types
```
void foo() { }
auto x;          // The compiler is unable to deduce the type of x
auto y{ };       // The compiler is unable to deduce the type of y
auto z{ foo() }; // z can't have type void, so this is invalid
```
### with const and constexpr
Prefix with const and constexpr
```
constexpr auto z { x }; // z will be type constexpr int (constexpr is reapplied)
```
### with string literals
For constant strings, it would be `const char*` and not `std::string`
```
auto s { "Hello, world" }; // s will be type const char*, not std::string
```
If you want the type deduced from a string literal to be `std::string` or `std::string_view`, you’ll need to use the `s` or `sv` literal suffixes
```
auto s1 { "goo"s };  // "goo"s is a std::string literal, so s1 will be deduced as a std::string
auto s2 { "moo"sv }; // "moo"sv is a std::string_view literal, so s2 will be deduced as a std::string_view
```
But in such cases, it may be **better to not use** type deduction.

### Benefits
1. Easier to read
2. Requires initilization as a good practice
3. Helps with skipping string initilization and avoidin conversions in some cases
```
std::string_view getString();   // some function that returns a std::string_view
std::string s1 { getString() }; // bad: expensive conversion from std::string_view to std::string 
auto s2 { getString() };        // good: no conversion required
```
### Downside
```
auto sum { add(5, 6) + gravity };
```
gravity in the above case carries a floating value, add(5,6) returning int would also convert to floating value due to float having **higher conversion strengh** over int and then the return type of sum would also be floating value. <br>
The user might have expect to be int but `auto` deduces it to be `float`.

## Function type deduction
In `C++14`, the `auto` keyword was extended to do function return type deduction.
```
auto add(int x, int y){
    return x + y;
}
```
### Downdisde 1
While using auto, all the branches of `if` or `else` should always return same data type, else error would be introduced
```
auto someFcn(bool b){
    if (b)
        return 5; // returns type int
    else
        return 6.7; // returns type double and produces error
}
int main(){
    auto val = someFcn(true);
}
```
**HUSTLE** Let's resolve the above issue using ternary operator
```
auto someFcn(bool b) { return b ? 5 : 6.7; }

int main() {
    auto val = someFcn(true); // val is an int with value 5
    return 0;
}
```
In above resolution, ternary operator always makes sure that same datatype would be returned, just like `+` or '`-` operator works with same data type only and in case of different data type it perform numerical promotion. <br>
Similary here, `5` being `int` data type would be numerically promoted to `float` and now ternary operator would be returning `5.0` instead. <br>
One can even use static_cast to cast either of the return types.

### Downside 2
Until `C++ 20`, we could not use `auto` for function parameters.
```
void addAndPrint(auto x, auto y){
    std::cout << x + y << '\n';
}
int main(){
    addAndPrint(2, 3); // case 1: call addAndPrint with int parameters
    addAndPrint(4.5, 6.7); // case 2: call addAndPrint with double parameters

    return 0;
}
```
The above code would work in `C++20` and here `auto` would triggering the `function templates` functionality to handle such cases.
### Downside 3
It can only be used for function which are local to a file and **not have forward declations in header** and definitions elsewhere. For e.g., the code below gives error:
```
auto foo();

int main(){
    std::cout << foo() << '\n'; // the compiler has only seen a forward declaration at this point
    return 0;
}

auto foo() { return 5; } // To resolve this one needs to move this function above the main function
```
Normal functions that return auto are typically only callable from within the file in which they are defined. 

### Trailing return type
To resolve the issue above we can use trailing return type:<br>
**add.h**
```
auto add() -> int;
```
**add.cpp**
```
#include "Header.h"
auto add() -> int {
    return 5;
}
```
**main.cpp**
```
#include "Header.h"

int main(){
    std::cout << add() << '\n'; 
    return 0;
}
```

Just like `add` in `add.h` we can add make other function prototypes to work with `auto` and `trailing return type`.


# Function Overloading
## Need
```
int addInteger(int x, int y){
    return x + y;
}
```
- Suppose if we want to pass float value to this function instead of integer
- Doing so we would see loss of precision
- To help we this we can do function overload by creating the same named function with `double` type parameter 
```
double add(double x, double y){
    return x + y;
}
```
NOTE : function’s **return type is not used** to differentiate overloaded functions.

## Factors consideres in overloading
1. Number of parameters - YES
2. Types of parameter - YES
3. Return type - NO
4. Ellipsis
5. Const or Volative (in member functions) - YES
6. Ref-Qualifierrs (in member function) - YES

### Taken care of 
1. Ellipses
```
void foo(int x, int y);
void foo(int x, ...); //differentiated from foo(int, int)
```
2. Function Signatures : return type is not included in the function signature
 (a) function name (b)number of parameters (c) parameter type (d) function-level qualifiers


### Not taken care
1. `const` qualifier
```
void print(int);
void print(const int); // not differentiated from print(int)
```
2. Return type
```
int getRandomValue();
double getRandomValue();
```

### Name Mangling
- The compiler mangles the name base on **number** and **type** of parameters, so that the linker has unique names to work with.
- `int fcn()` might compile to name `__fcn_v`, whereas `int fcn(int)` might compile to name `__fcn_i`


### Overload Resolution
- With overloaded functions, there can be many functions that can potentially **match a function call**
- The process of matching function calls to a specific overloaded function is called overload resolution
  
Overload match is resolved in steps:
1. A single matching function was found. This function is considered to be the best match

2. If match not found then apply a bunch of **trivial conversions** to the argument to find the match. Matches made via the trivial conversions are considered exact matches.
```
void print(const int) { }
print(x); // x trivially converted to const int
```
Example 1 : `non-const` type can be trivially converted to a `const` type
<br><br>
Example 2 : `non-reference` type to a `reference` type  and vice-versa
<br><br>
3. If no exact match is found, the compiler tries to find a match by applying **numeric promotion** to the argument(s). E.g. `int` or `double`
```
void print(int) { }
void print(double) { }

int main(){
    print('a'); // promoted to match print(int)
    print(true); // promoted to match print(int)
    print(4.5f); // promoted to match print(double)
}
```
<br><br>
4. If no match is found still, then compiler starts applying **numeric conversions**
```
void print(double) { }
void print(std::string) { }
int main(){
    print('a'); // 'a' converted to match print(double)
    return 0;
}
```
**NOTE** : Matches made by applying numeric promotions take **precedence** over any matches made by applying numeric conversions. <br><br>
5. If it is still not a match then compiler relies on **user defined conversions**
```
class X 
{
public:
    operator int() { return 0; } // Here's a user-defined conversion from X to int
};

void print(int) { } //this would be called
void print(double) { } 

int main(){
    X x; 
    print(x); // x is converted to type int using the user-defined conversion from X to int
    return 0;
}
```
If `print(int)` is also not defined then `print(double)` gets called due to numerical promotion.<br><br>
<br><br>
6. If no match is found via user-defined conversion, the compiler will look for a matching function that uses **ellipsis**.<br><br>
7. Else **GIVE-UP**

### Ambiguos Conversions
An ambiguous match occurs when the compiler finds two or more functions that can be made to match in the same step. <br>
**Example 1**
```
void print(int) { }
void print(double) { }

int main(){
    print(5L); // 5L is type long
    return 0;
}
```
`5L` is of type `long`: 
1. The compiler would first look for exact match `print(long)`
2. Then will **try for numeric promotion** but `long` cannot be promoted since promotion are for narrow to wider datatype
3. The compiler will try to find a match by applying **numeric conversions** to the `long` argument.
4. If the long argument is numerically converted into an `int`, then the function call will match `print(int)`
5. If the long argument is instead converted into a `double`, then it will match `print(double)` instead

**Example 2**
```
void print(unsigned int) { }
void print(float) { }

int main(){
    print(0); // int can be numerically converted to unsigned int or to float
    print(3.14159); // double can be numerically converted to unsigned int or to float
}
```
- We might expect `0` to resolve to `print(unsigned int)` and `3.14159` to resolve to `print(float)`
- Since the `int` value `0` can be numerically converted to either an `unsigned int` or a `float`, so either overload matches equally well, and the result is an ambiguous function call.
- The same applies for the conversion of a `double` to either a `float` or `unsigned int`

### Resolving Ambiguous Matches
1. Make an exact overloading function
2. Static_cast the argument to match the existing function parameter
3. In case of constact initilizer, use the literal suffix to match function parameter

### Multiple parameter match
```
void print(char, int) { }
void print(char, double) { }
void print(char, float) { }

int main(){
    print('x', 'a');
}
```

In the above function case, the 1st parameter is matched in all the cases, but for 2nd parameter is best matched in case of `print(char,int)`

## Deleting Function
### =delete specifier
```
void printInt(int x) { }

int main() {
    printInt(5);    // okay: prints 5
    printInt('a');  // prints 97 -- does this make sense?
    printInt(true); // print 1 -- does this make sense?
}
```

Suppose if you don't want the `printInt(char)` and `printInt(bool)` to be invoked (if they are stopped at the first place then further `printInt(int)` would't be converted via number conversion) then you can delete the `printInt(char)` and `printInt(bool)` functions.

```
void printInt(int x) { }
void printInt(char) = delete; // calls to this function will halt compilation
void printInt(bool) = delete; // calls to this function will halt compilation

int main() {
    printInt(97);   // okay
    printInt('a');  // compile error: function deleted
    printInt(true); // compile error: function deleted
}
```
Now the deleted function function calls would give compilation error. <br><br>
```
printInt(5.0);
```
Suprisingly the code above will give ambiguos compilation error. <br>
- First, the compiler checks to see if exact match `printInt(double)` exists. It does not.
- All the printInt(int/bool/char) are considered good match after implcit conversions
- Since both all of them are viable candidates(even if they are deleted functions), the compiler cannot choose between them, resulting in an "ambiguous match" error. <br><br>

### Delete all non-matching overloads
If we want to consider only one type of data-type to be matched and rest all to be ignored even for implicit conversions then we can use templates to delete all of them
```
void printInt(int x) { }

template <typename T>
void printInt(T x) = delete;

int main() {
    printInt(97);   // okay
    printInt('a');  // compile error
    printInt(true); // compile error
}
```
the above code takes only `printInt(int)` and not other overloads.

## Default Arguments
- Default arguments are handled by the compiler at the call site
- Only `=` operator can be used and not `{}` initializer


Rules of setting default arguments:
1. Explicitly provided arguments must be the leftmost arguments (arguments with defaults cannot be skipped)
```
print();           // okay: both arguments defaulted
print("Macaroni"); // okay: d defaults to 10.0
print(20.0);       // error: does not match above function (cannot skip argument for sv)
```
We cannot start from middle or right, start from left and fill each argument.

2. If a parameter is given a default argument, all subsequent parameters (**to the right) must also be given default arguments.**
```
void print(int x=10, int y); // not allowed
```
3. The default argument can be declared in **either** the forward declaration or the function definition, but not both. **Best** practice is to declare the default argument **in the forward declaration**
```
void print(int x, int y=4); // forward declaration

void print(int x, int y=4) { // error: redefinition of default argument
    std::cout << "x: " << x << '\n';
    std::cout << "y: " << y << '\n';
}
```
### Default argument and function overloading
```
void print(std::string_view s) { }
void print(char c = ' ') { }

int main() {
    print("Hello, world"); // resolves to print(std::string_view)
    print('a'); // resolves to print(char)
    print(); // resolves to print(char)
}
```
The function call to `print()` acts as if the user had explicitly called `print(' ')`, which resolves to `print(char)`.


## Function Templates
- This came as a result of **DRY** (don’t repeat yourself) principle. 
- In a template we can use one or more **placeholder** types. A placeholder type represents some type that is not known at the time the template is written, but that will be provided later
- Once a template is defined, the **compiler can use the template to generate as many overloaded functions** (or classes) as needed, each using different actual types!

### Types
C++ supports 3 different kinds of template parameters:
1. Type template parameters (where the template parameter represents a type).
2. Non-type template parameters (where the template parameter represents a constexpr value).
3. Template template parameters (where the template parameter represents a template).

```
template <typename T> // this is the template parameter declaration
T max(T x, T y) // this is the function template definition for max<T>
{
    return (x < y) ? y : x;
}
```

NOTE : There is no difference between the `typename` and `class` keywords in this context. But `class` keyword is older. 

### Naming Convention
We can use these conventions to name `T` in place:
1. Starting with a capital letter (e.g. `Allocator`). The standard library uses this naming convention.
2. refixed with a T, then starting with a capital letter (e.g. `TAllocator`)

### Function Template Initilization
```
max<int>(1, 2)
```
The process of creating functions (with specific types) from function templates (with template types) is called **function template instantiation** <br>

The result of compilation looks like this for `max<int>(1, 2)`:
```
template <typename T>
T max(T x, T y);

template<>
int max<int>(int x, int y) // the generated function max<int>(int, int)
{
    return (x < y) ? y : x;
}
```
### Tempalte Argument Deduction
We can let the compiler deduce the type from the function call too:
```
template <class T> 
T max(T x, T y) {
    return (x < y) ? y : x;
}

int main(){
	std::cout << max<>(2, 3); //int type template would be called 
	std::cout << max(2, 3); //int template and non-template type would be called 
    	std::cout << max(2.3, 3.5); //float template and non-template  type would be called
}
```
- In `max<>()` case the compiler will consider only template functions
- In `max()` case the compiler will consider both template and non-template functions. It can call `max(int, int)`
if present.

**Best practice** : Favor the normal function call syntax when making calls to a function instantiated from a function template. <br>

### Template with non template params
```
template <typename T>
int someFcn (T, double){
    return 5;
}
```

T can vary but 2nd parameter needs to be `float` or `double` value

### non-working situations
```
template <typename T>
T addOne(T x){
    return x + 1;
}
int main()
{
    std::string hello { "Hello, world!" };
    std::cout << addOne(hello) << '\n';
}
```
`string-type + 1` wouldn't work here

### Semantical issues
```
template <typename T>
T addOne(T x){
    return x + 1;
}

int main(){
    std::cout << addOne("Hello, world!") << '\n';
    return 0;
}
```
OUTPUT
```
ello, world!
```
The compiler does not have any way to check that such a function actually makes sense semantically. <br>

**SOLUTION** <br>
We can avoid this situation by using `=delete` operator
```
template <typename T>
T addOne(T x) {
    return x + 1;
}

// Use function template specialization to tell the compiler that addOne(const char*) should emit a compilation error
// const char* will match a string literal
template <>
const char* addOne(const char* x) = delete;

int main(){
    std::cout << addOne("Hello, world!") << '\n'; // compile error
}
```

### Multiple file usage
Multiple file usage of template functions doesn't work the same way as non-template functions. <br>
**Header.h**
```
template <typename T>
T addOne(T x);
```
**Source.cpp**
```
#include "Header.h"
template<typename T>
T addOne(T x) {
    return x + 1;
}
```
**main.cpp**
```
#include <iostream>
#include "Header.h"

int main(){
    std::cout << addOne(2);
}

```

The code above gives **linker error** as compiler doesn't see any definition os addOne template anywhere even in `source.cpp`. 

**SOLUTION** <br>
Conventional way to use template in mutliple files is
- Define template functions in header files only
- And they don't violate ODR as they are **implicitly inline**

**EXAMPLE 1** <br>
**Header.h**
```
template <typename T>
T addOne(T x) {// function template definition
    return x + 1;
}

```
**Source.cpp**
```
#include "add.h" // import the function template definition
int main(){
    std::cout << addOne(1) << '\n';
}
```
**EXAMPLE 2** <br>
**max.h**
```
template <typename T>
T max(T x, T y){
    return (x < y) ? y : x;
}
```
**foo.cpp**
```
#include "max.h" // import template definition for max<T>(T, T)
void foo(){
	std::cout << max(3, 2) << '\n';
}
```
**main.cpp**
```
#include "max.h" // import template definition for max<T>(T, T)
void foo(); // forward declaration for function foo

int main(){
    std::cout << max(3, 5) << '\n';
    foo();
}
```

As you can see we are still going with defining non-template functions in `.cpp` files but template but tempalte functions would be defined in `.h` files only.

### Downsides
1. First, the compiler will create (and compile) a function for each function call with a unique set of argument types. So while function templates are compact to write, they can expand into a crazy amount of code, which **can lead to code bloat and slow compile times**.
2. The bigger downside of function templates is that they tend to produce crazy-looking, borderline unreadable error messages that are much **harder to decipher** than those of regular functions.

## Multiple template type Functions
```
#include <iostream>

template <typename T>
T max(T x, T y)
{
    return (x < y) ? y : x;
}

int main(){
    std::cout << max(2, 3.5) << '\n';  // compile error
}
```

- The code above generates compilation error
- If we are wondering that type conversion could happen then we should remember that **type conversion** is only taken care in function overload and **not template type deduction.**

**SOLUTION** <br>
1. Use static_cast
2. Provide explicit type template argument
```
template <typename T>
T max(T x, T y){
    return (x < y) ? y : x;
}

int main(){
    // we've explicitly specified type double, so the compiler won't use template argument deduction
    std::cout << max<int>(2, 3.5) << '\n';  //This would give data loss warnings
    std::cout << max<double>(2, 3.5) << '\n'; // Here int parameter will be implicitly converted to a double.
    return 0;
}
```
3. Multiple Template type parameters
```
template <typename T, typename U> // We're using two template type parameters named T and U
T max(T x, U y) {// x can resolve to type T, and y can resolve to type U
    return (x < y) ? y : x; // uh oh, we have a narrowing conversion problem here
}

int main(){
    std::cout << max(2, 3.5) << '\n';
}
```
**ISSUES with this code:** <br>
- The ternary operator would return `double` as `double` has higher precedance over `int` but the return type is set to `int` and it will give **data loss warnings**
- Even if we make it `U`, we can still flip the arguments to make the situation same
- Best is to use `auto` keyword
```
template <typename T, typename U>
auto max(T x, U y){
    return (x < y) ? y : x;
}
```
4. Abbreviated function templates
When the **auto** keyword is used as a parameter type in a normal function, the compiler will **automatically convert the function into a function template** with each auto parameter becoming an independent template type parameter.
```
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}
```
which is the same as the `max` function template we wrote above.


## Non-template type parameters
A non-type template parameter can be any of the following types:
```
An integral type
An enumeration type
std::nullptr_t
A floating point type (since C++20)
A pointer or reference to an object
A pointer or reference to a function
A pointer or reference to a member function
A literal class type (since C++20)
```
**Example 1**
```
std::bitset<8> bits{ 0b0000'0101 }; // The <8> is a non-type template parameter
```
**Example 2**
```
template <int N> // declare a non-type template parameter of type int named N
void print(){
    std::cout << N << '\n'; // use value of N here
}

int main(){
    print<5>(); // 5 is our non-type template argument
}
```

### Usage
```
double getSqrt(double d){
    assert(d >= 0.0 && "getSqrt(): d must be non-negative");
    // The assert above will probably be compiled out in non-debug builds
    if (d >= 0)
        return std::sqrt(d);

    return 0.0;
}

int main(){
    std::cout << getSqrt(5.0) << '\n';
    std::cout << getSqrt(-5.0) << '\n';
}
```
- The code above will give assertions only in run time.
- But if we want to have assertions in compile time we need to use `static_assert` so that these errors woudl be caught at compile time.
- But for `static_assert` we need `constexpr` which can't do for function parameters
- We will chose non-template type parameters instead

```
template <double D> // requires C++20 for floating point non-type parameters
double getSqrt(){
    static_assert(D >= 0.0, "getSqrt(): D must be non-negative");
    if constexpr (D >= 0) // ignore the constexpr here for this example
        return std::sqrt(D); // strangely, std::sqrt isn't a constexpr function (until C++26)
    return 0.0;
}

int main(){
    std::cout << getSqrt<5.0>() << '\n';
    std::cout << getSqrt<-5.0>() << '\n'; //generates error for this
}
```
**NOTE** :Non-type template parameters are used primarily when we need to pass constexpr values to functions (or class types) so they can be used in contexts that require a constant expression.

### Implicit Conversions
**If a function template is overloaded** for different kinds of non-type template parameters, it can very easily result in an **ambiguous** match
```
template <int N> // int non-type template parameter
void print(){
    std::cout << N << '\n';
}

template <char N> // char non-type template parameter
void print(){
    std::cout << N << '\n';
}

int main(){
    print<5>();   // ambiguous match with int N = 5 and char N = 5
    print<'c'>(); // ambiguous match with int N = 99 and char N = 'c'
}
```

### Using auto
```
#include <iostream>

template <auto N> // deduce non-type template parameter from template argument
void print(){
    std::cout << N << '\n';
}

int main(){
    print<5>();   // N deduced as int `5`
    print<'c'>(); // N deduced as char `c`
}
```
In this case, there is only **one function template**, so there is no possible ambiguity.


# References and Pointers
## Introduction
Compound data types (also sometimes called composite data types) are data types that can be constructed from fundamental data types.
1. Functions
2. Arrays
3. Pointer types: `Pointer to object`, `Pointer to function` 
4. Pointer to member types: `Pointer to data member`, `Pointer to member function`
5. Reference types: `L-value references`, `R-value references`
6. Enumerated types: `Unscoped enumerations`, `Scoped enumerations`
7. Class types: `Structs`, `Classes`, `Unions`

## lvalue and rvalue
```
 ++x; // This expression statement has the side-effect of incrementing x
```
Besides producing values and side effects, expressions can do one more thing: **they can evaluate to objects or functions**. 

### Properties of expressions
All expressions in C++ have two properties: 
1. a type
2. a value category

### The TYPE of an expression
The compiler can use the type of an expression to determine whether an expression is valid in a given context. <br>
**Example 1**
```
auto v1 { 12 / 4 }  //valid
```
**Example 2 **
```
void print(int x){
    std::cout << x << '\n';
}
print("foo");  //invalid
```

**Type** of an expression must be determinable at compile time and the **value** of an expression may be determined at either compile time.

### VALUE of expression
```
x = 5; // valid: we can assign 5 to x
5 = x; // error: can not assign value of x to literal value 5
```
**QUESTION** : How does the compiler know which expressions can legally appear on either side of an assignment statement? <br>
**ANSWER** :The answer lies in the second property of expressions: `the value category` <br>
The value category of an expression (or subexpression) indicates whether an expression resolves to `a value`, `a function`, or `an object` of some kind.
- Expressions on the **left hand side** can only be `lvalue` something what has name and address and is modifiable.
- `5` cannot be on the left hand side as it is not modifiable
- The expression on the **right-hand side** of the assignment operator can be either an lvalue or an rvalue.
- If the right-hand side expression is an lvalue, it is implicitly converted to an rvalue by creating a temporary copy.

### Lvalue and Rvalue expressions
**LVALUE**
- **lValue** is an expression that evaluates to an identifiable `object` or `function` (or `bit-field`)
-  lvalues come in two subtypes: `modifiable lvalue` and `non-modifiable lvalue` like `const` variables
-  _Lvalue expressions evaluate to an identifiable object._

**RVALUE**
- `r-value` is an expression that is not an lvalue
- Rvalue expressions evaluate to a `value`
-  Commonly seen rvalues include `literals`, `return value of functions`, `operators that return by value`
-  Examples are `return5()`, `x + 1`, and `static_cast<int>(d)` as **they produce temprary values**.
-  _Rvalue expressions evaluate to a value._

**TIP**: <br>
If you’re not sure whether an expression is an lvalue or rvalue, try taking its address using `operator&`, which requires its operand to be an lvalue. If &(expression); compiles, expression must be an lvalue. <br>

**INSIGHT - C-STYLE STRINGs**<br>

A C-style string literal is an constant **lvalue** because C-style strings (which are C-style arrays) decay to a pointer. If the array were an rvalue (a temporary value without an address), it wouldn't be possible to obtain a pointer to its first element.<br>
Even though the string literal itself is a temporary array, it is considered an lvalue so that the array-to-pointer decay can occur, allowing expressions like `"hello"` to be implicitly converted to a pointer to its first character `(char*)`.<br>

### lValue to rValue conversion
```
int x { 5 };
int y { x };
```
- lvalue expressions will implicitly convert to rvalue expressions in contexts where an rvalue is expected but an lvalue is provided.
-  lvalue expression x undergoes an lvalue-to-rvalue conversion, which evaluates to value 5, which is then used to initialize y

### Identifying lvalue and rValue
- **Lvalue** expressions are those that evaluate to variables or other identifiable objects that persist beyond the end of the expression
- **Rvalue** expressions are those that evaluate to literals or values returned by functions/operators that are discarded at the end of the expression.

## lValue Reference
- In C++, a **reference** is an alias for an existing object
- A reference is essentially identical to the object being referenced
- We use `&` to denote a reference
<br>
**Types**
  1. lvalue reference
  2. rvalue reference

### reference variables
lvalue reference variable is a variable that acts as a reference to an lvalue <br>	
```
int x { 5 };
int& ref { x };
```
When a reference is initialized with an object (or function), we say it is **bound** to that object also called as **reference binding**.
- We can bind to only modifiable value and not const value
```
int x { 5 };
int& ref { x }; // valid: lvalue reference bound to a modifiable lvalue

const int y { 5 };
int& invalidRef { y };  // invalid: can't bind to a non-modifiable lvalue
```
Lvalue references can’t be bound to non-modifiable lvalues or rvalues (otherwise you’d be able to change those values through the reference, which would be a **violation of their const-ness**). <br>
<br>
**type** of the reference must match the type of the referent<br>
```
int x { 5 };
int& ref { x }; // okay: reference to int is bound to int variable

double y { 6.0 };
int& invalidRef { y };
```
- Reference **cannot** be changed to reference another object once initialized.
### Scope
- It has same scope as normal variables
- Reference can be destroyed before the object it is referring to
```
int x { 5 };

{
int& ref { x };   // ref is a reference to x
std::cout << ref << '\n'; // prints value of ref (5)
} // ref is destroyed here -- x is unaware of this
```
### Dangling references
When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists.
```
const std::string& getProgramName(){
    const std::string programName { "Calculator" }; // now a non-static local variable, destroyed when function ends
    return programName;
}
```
The function call above leads to undefined behaviour. 

### References aren’t objects
- The compiler will optimize references away by replacing all occurrences of a reference with the referent
- You can’t have a reference to a reference, since an lvalue reference must reference an identifiable object
```
int var{};
int& ref1{ var };
int& ref2{ ref1 };
```
`ref1` is a reference to `var`, when used in an expression (such as an initializer), `ref1` evaluates to `var`. So `ref2` is just a normal lvalue reference (as indicated by its type `int&`), bound to `var`.

### reference to const
```
const int x { 5 };    // x is a non-modifiable lvalue
const int& ref { x };
```
Such a reference is called an **lvalue reference to a const value**. They can be used to access but not modify the value being referenced. <br><br>

**lvalue const reference to modifiable value** <br>
```
int x { 5 };          // x is a modifiable lvalue
const int& ref { x }; // okay: we can bind a const reference to a modifiable lvalue

std::cout << ref << '\n'; // okay: we can access the object through our const reference
ref = 7;                  // error: we can not modify an object through a const reference
```
A const reference can refer to a modifiable value but it still cannot modify the value via reference.

**lvalue reference to const variables** <br>
although lvalue reference can't refere to constant values but constant lvalue references can refer to constant values.
```
const int& ref { 5 }
```
- When this happens, a **temporary object is created** and initialized with the rvalue, and the reference to const is bound to that temporary object.
- When a const lvalue reference is directly bound to a temporary object, the **lifetime of the temporary object is extended** to match the lifetime of the reference
```
const int& ref { 5 }; // The temporary object holding value 5 has its lifetime extended to match ref
std::cout << ref << '\n'; // Therefore, we can safely use it here
```
When both `ref` and the temporary object go out of scope and are destroyed at the end of the block.

### Constexpr references
- Constexpr references have a particular limitation: they can only be bound to objects with static duration (either **globals or static locals**)
- This is because the compiler knows where static objects will be instantiated in memory, so it can treat that address as a compile-time constant
- A constexpr reference cannot bind to a (non-static) local variable. This is because the address of local variables is not known until the function they are defined within is actually called
```
int g_x { 5 };

int main(){
    constexpr int& ref1 { g_x }; // ok, can bind to global
    static int s_x { 6 };
    constexpr int& ref2 { s_x }; // ok, can bind to static local
    int x { 6 };
    constexpr int& ref3 { x }; // compile error: can't bind to non-static object
    static const int s_x { 6 }; // a const int
    constexpr const int& ref2 { s_x }; 
}
```

### Summary
- Lvalue references can only bind to modifiable lvalues.
- Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues
- **Temporaries returned from a function** (even ones returned by const reference) are **not eligible** for lifetime extension

## Pass by lvalue reference
- In pass by value, fundamental data types are cheap to copy
- But class types are difficult to copy for `e.g. std::string`

<br>**SOLUTION**<br>
```
void printValue(std::string& y) { // type changed to std::string&
    std::cout << y << '\n';
} // y is destroyed here

int main(){
    std::string x { "Hello, world!" };
    printValue(x); // x is now passed by reference into reference parameter y (inexpensive)
}
```
- When using pass by reference, we declare a function parameter as a **reference type** (or const reference type)
- When the function is called, each reference parameter is **bound** to the appropriate argument
- When using pass by reference, any changes made to the reference parameter will affect the argument
- In pass by reference we cannot pass `const` or `literal`
```
const int z { 5 };
printValue(z); // error: z is a non-modifiable lvalue
printValue(5); // error: 5 is an rvalue
```
**SOLTUION** <br>
 Pass by const lvalue reference can bind to modifiable lvalues, non-modifiable lvalues, and rvalues.

<br><br>
**BEST PRACTICE** <br>
- As a rule of thumb, pass fundamental types by **value**, and `class` (or `struct`) types by const reference
- Other common types to pass by **value**: `enumerated` types and `std::string_view`
- Other common types to pass by (const) **reference**: `std::string`, `std::array`, and `std::vector`
- An object is cheap to copy if it uses 2 or fewer “words” of memory (<= 2 * sizeof(void*))
- In some places copy by value give compiler oppurtunity to perform move semantics

###  std::string_view over const std::string&
In most cases, `std::string_view` is the better choice, as it can handle a wider range of argument types efficiently.
```
void doSomething(const std::string&);
void doSomething(std::string_view);   // prefer this in most cases
```
**Exceptions** <br>
If your function needs to call some other function that takes a `C-style string` or `std::string` parameter, then `const std::string&` may be a better choice, as `std::string_view` is not guaranteed to be null-terminated<br>

With a `std::string_view` value parameter, it can handle inexpensively:
1. std::string
2. std::string_view
3. C-style string or string literal

With `const std::string&`, it can handle
1. `std::string` inexpensively
2. `std::string_view` needs to be explcitly get converted to `std::string` via static_cast which is expensive
3. `C-style string` too needs to explcitly convert to `std::string` which is expensive

# Pointers
## Address of &
The **address-of operator (&)** returns the memory address of its operand. 
```
int x{ 5 };
std::cout << x << '\n';  // print the value of variable x
std::cout << &x << '\n'; // print the memory address of variable x
```
Memory addresses are typically printed as hexadecimal values

## Deference Operator
The **dereference operator (*)** returns the value at a given memory address as an lvalue. It is an unary operator.
```
std::cout << x << '\n';  // print the value of variable x
std::cout << &x << '\n'; // print the memory address of variable x
std::cout << *(&x) << '\n'; // print the value at the memory address of variable x
```
**INSIGHT** <br>
The address-of operator (`&`) and dereference operator (`*`) work as opposites: address-of gets the address of an object, and _**dereference gets the object**_ at an address.
```
int x{ 3 };
std::cout << &x << std::endl;
std::cout << *(&x) << std::endl;

*(&x) = 4; //Since * returns lValue, we can make changes inside that lValue
std::cout << x << std::endl;
```

## Introduction to Pointers
A pointer is an object that **holds a memory address** (typically of another variable) as its value.

## Initialization
1. Pointers are not initilialized by default and due to this they can contain garbage adderss (also called wild pointers)
2. Dereferencing wild pointers can result in undefined behaviour
```
int x{ 5 };

int* ptr;        // an uninitialized pointer (holds a garbage address)
int* ptr2{};     // a null pointer (we'll discuss these in the next lesson)
int* ptr3{ &x }; // a pointer initialized with the address of variable x
```
Once we have a pointer holding the address of another object, we can then use the dereference operator (*) to **access the lvalue** at that address.
```
int x {4};
  int* ptr{};
  if(ptr == nullptr)
      ptr = &x;
  *ptr = 5;
```
**NOTE** : So when we say, “an integer pointer”, we really mean “a pointer to an integer”. <br>

## Pointing to datatype
The type of the pointer has to match the type of the object being pointed to:
```
int i{ 5 };
double d{ 7.0 };

int* iPtr{ &i };     // ok: a pointer to an int can point to an int object
int* iPtr2 { &d };   // not okay: a pointer to an int can't point to a double object
double* dPtr{ &d };  // ok: a pointer to a double can point to a double object
double* dPtr2{ &i }; // not okay: a pointer to a double can't point to an int object
```

## Assignment to address and value
We can use assignment with pointers in two different ways:

1. To change what the pointer is pointing at (by assigning the pointer a new address)
2. To change the value being pointed at (by assigning the dereferenced pointer a new value)

## Pointers and references
-  Pointers and references both provide a way to indirectly access another object.
-  . The primary difference is that with pointers, we need to explicitly get the address to point at, and we have to explicitly dereference the pointer to get the value.
-  With references, the address-of and dereference happens implicitly.
-  References must be initialized, pointers are not required to be initialized (but should be).
-  References are not objects, pointers are.
-  References can not be reseated (changed to reference something else), pointers can change what they are pointing at.
-  References must always be bound to an object, pointers can point to nothing
-  References are “safe” (outside of dangling references), pointers are inherently dangerous

## What does & actually return
Contrary to belied `&` **doesn't return address** of a variables, instead it actually pointer to that variable, we can know this by using typeid().
```
int x{ 4 };
std::cout << typeid(&x).name();
```
**OUTPUT**
```
int * __ptr64
```

## Size of pointers
Pointer on a 32-bit machine is 32 bits (4 bytes). With a 64-bit executable, a pointer would be 64 bits (8 bytes). Note that this is true regardless of the size of the object being pointed to.
```
std::cout << sizeof(chPtr) << '\n'; // prints 4
std::cout << sizeof(iPtr) << '\n';  // prints 4
std::cout << sizeof(ldPtr) << '\n'; // prints 4
```
A **dangling pointer** is a pointer that is holding the address of an object that is no longer valid.

```
int x{ 5 };
int* ptr{ &x };
std::cout << *ptr << '\n'; // valid
{
    int y{ 6 };
    ptr = &y;
    std::cout << *ptr << '\n'; // valid
} // y goes out of scope, and ptr is now dangling

std::cout << *ptr << '\n'; // undefined behavior from dereferencing a dangling pointer
```

## Null Pointers
When a pointer is holding a null value, it means the pointer is **not pointing at anything**. <br>
The easiest way to create a null pointer is to use value initialization:<br>
```
int main(){
    int* ptr {}; // ptr is now a null pointer, and is not holding an address
    return 0;
}
```
Because we can use assignment to change what a pointer is pointing at, a pointer that is initially set to null can later be changed to point.


## nullptr keyword
```
int* ptr { nullptr }; // can use nullptr to initialize a pointer to be a null pointer
```

## dereferencing nummptr
- Dereferencing nummptr can lead to undefined behaviour or application crash.
- I would mean “go to the address the pointer is pointing at and access the value there”.

## Checking nullptr
```
if (ptr == nullptr)
  \\something

(nullPtr==nullptr ? "null\n" : "non-null\n");
```
**Boolean check**<br>
Pointers will also implicitly convert to Boolean values: a **null pointer** converts to Boolean value **false**, and a **non-null pointer** converts to Boolean value **true**
```
 if (ptr) // implicit conversion to Boolean
        std::cout << "ptr is non-null\n";
```

## Checking Dangling pointers
- There is actually no way to check if the pointers are dangling or not
- We need to avoid having any dangling pointers in our program in the first place
- We do that by ensuring that any pointer that is not pointing at a valid object is set to `nullptr`.

**Good Practice** <br>
- When an object is destroyed, any pointers to that object will be left dangling.
- Such pointers are not nulled automatically! It is the programmer’s responsibility to ensure that all pointers to an object that has just been destroyed are properly set to `nullptr`.

### Legacy null pointer
Both 0 and NULL should be **avoided** in modern C++. <br>

**NOTE** :  The literal `0`, when used in the context of a null pointer, will be translated into whatever address the architecture uses to represent a null pointer.


## Favor references over pointers
A null pointer runs the risk of being dereferenced, and the ability to change what a pointer is pointing at can make creating dangling pointers easier. <br>

- Since references can’t be bound to null, we don’t have to worry about null references
- And because references must be bound to a valid object upon creation and then can not be reseated, dangling references are harder to create.

## Pointers to constant
We cannot point to a constant variable via non-constant pointer as this would allow the programmer to dereference the pointer and change the value
```
const int x { 5 }; // x is now const
int* ptr { &x };   // compile error: cannot convert from const int* to int*
```
**SOLTUION**<br>
A **pointer to a const** value  is a  pointer that points to a constant value. <br>
```
const int x{ 5 };
const int* ptr { &x }; // okay: ptr is pointing to a "const int"
```
In the above example, `ptr` points to a `const int`. Because the data type being pointed to is const, the value being pointed to can’t be changed. <br>

**HOWEVER** <br>
because a pointer to const is not const itself (it just points to a const value), we can still change what the pointer is pointing at by assigning the pointer a new address.
```
const int x{ 5 };
const int* ptr { &x }; // ptr points to const int x

const int y{ 6 };
ptr = &y; // okay: ptr now points at const int y
```
Pointer to constant can still point to non-constant variable:
```
int x{ 5 }; // non-const
const int* ptr { &x }; // ptr points to a "const int"
*ptr = 6; //still not allowed
```
## Constant Pointers
- A const pointer is a pointer whose **address can not be change**d after initialization.
- Use the const keyword **after the asterisk** in the pointer declaration
```
int x{ 5 };
int* const ptr { &x };
```
**NOTE** : A const pointer **must be initialized** upon definition, and this value can’t be changed via assignment <br>
**However**, because the value being pointed to is non-const,**it is possible to change the value** being pointed to via dereferencing the const

## Const pointer to a const value
A const pointer to a const value can not have its address changed, nor can the value it is pointing to be changed through the pointer.
```
int value { 5 };
const int* const ptr { &value };
```

## Pass by Address
Method sof pass the values:
1. Pass by value
2. Pass by reference
3. Pass by address (using pointers)

```
void printByValue(std::string val) // The function parameter is a copy of str
void printByReference(const std::string& ref) // The function parameter is a reference that binds to str
void printByAddress(const std::string* ptr) // The function parameter is a pointer that holds the address of str
```
**How does it work** <br>
1.  Instead of providing an object as an argument, the **caller provides an object’s address** (via a pointer)
2.  `&object` returns the pointer to object which on passing is copied to function parameter pointer
3.  Later we can dereference the pointer to access the lvalue
4.  When we pass by address, **we’re not copying the actual std::string object** -- we’re just copying the pointer (holding the address of the object) from the caller to the called function.
5.  Since pointer is only 4 or 8 bytes, so **copying a pointer is always fast**.

If we already had a pointer variable holding the address of `str`, , we could use that instead:
```
std::string* ptr { &str }; // define a pointer variable holding the address of str
printByAddress(ptr)
```

### Things to note
1. Pass by address allows the function to modify the argument’s value unless it is a pointer to constant value
2. When passing a parameter by address, care should be taken to ensure the pointer is not a null pointer
```
void print(int* ptr){
    if (ptr) {  // if ptr is not a null pointer    
        std::cout << *ptr << '\n';
    }
//OR
    if (!ptr) // if ptr is a null pointer, early return back to the caller
        return;
//OR
    assert(ptr); // fail the program in debug mode if a null pointer is passed 
}
```
4. Prefer `pass by const reference` over `pass by address` as `pass by const reference` needs to have a variable with address and can even take `literal`

##  “optional” arguments
```
void greet(const std::string* name=nullptr){
    std::cout << "Hello ";
    std::cout << (name ? *name : "guest") << '\n';
}
int main(){
    greet(); // we don't know who the user is yet
}
```
The name parameter defaults to nullptr here. We can also use function overloading and make a functionwhich doesn't have any parameter which the above function call gets redirected to instead.<br>

## Changing what a pointer parameter points at
```
void nullify(int* ptr2){
    ptr2 = nullptr; // Make the function parameter a null pointer
}

int main(){
    int x{ 5 };
    int* ptr{ &x }; // ptr points to x
    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n"); ---// ptr is non-null
    nullify(ptr);
    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n"); ---// ptr is non-null
}
```
In the code above `ptr` that is pointing to `x` **doesn't become** `null` <br>
**WHY ?** <br>
Because when we pass by address we are only copying the address from argument to the pointer parameter, so we only making the parameter pointer point to `null` now and this doesn't impact the pointer pointing to x

## Pass by address and reference
Now instead of copying the addres froma  pointer we willl pass the address by reference
```
void nullify(int*& ptr2){
    ptr2 = nullptr; // Make the function parameter a null pointer
}

int main(){
    int x{ 5 };
    int* ptr{ &x }; // ptr points to x
    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n"); ---// ptr is non-null
    nullify(ptr);
    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n"); ---// ptr is non
}
```
Here `refptr` is bound to `ptr`. This means any changes to `refptr` are made to `ptr`.

## 0 and NULL are obsolete
- `0` can be confused if it is a literal or a null-pointer.
- The definition of preprocessor macro `NULL`** is not defined** by the language standard. It can be defined as `0`, `0L`, `((void*)0)`

```
void print(int x) { // this function accepts an integer
	std::cout << "print(int): " << x << '\n';
}

void print(int* ptr) {// this function accepts an integer pointer
	std::cout << "print(int*): " << (ptr ? "non-null\n" : "null\n");
}

int main() {
	print(0);   // This calls print(int) as 0 is thought as a literal
	print(NULL); //This can call anyone. In VS 2022 is calls pint(int) 
}
```

## std::nullptr_t
- The answer is that nullptr has type `std::nullptr_t`
- `std::nullptr_t` can only hold one value
- We can make a function that taken only `std::nullptr_t`

```
void print(std::nullptr_t){
    std::cout << "in print(std::nullptr_t)\n";
}

void print(int*){
    std::cout << "in print(int*)\n";
}

int main(){
    print(nullptr); // calls print(std::nullptr_t)

    int x { 5 };
    int* ptr { &x };

    print(ptr); // calls print(int*)

    ptr = nullptr;
    print(ptr); // calls print(int*) (since ptr has type int*)
}
```
Remember that function overloading **matches on types**, not values.


## Pass by reference is pass by address
- References are normally implemented by the compiler using pointers
- This means that behind the scenes, pass by reference is essentially just a pass by address
- Pass by address just copies an address from the caller to the called function -- which is just passing an address by value.

## Return by reference and address
