# LearningCPP

# Introduction
The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86/x64 family, which you may be using) have instructions that can be a variable length. <br>

**Assemly language**, for e.g., ```mov al, 061h``` sits on top of Machine Language which is atleast readable and writable and is still used today when speed is critical. An **Assembler** converts Assembly langugage to Machine langugage. <br>
It is still not very portable. <br>

Much like assembly programs, programs written in high level languages must be translated into a format the computer can understand before they can be run. There are two primary ways this is done: **compiling and interpreting**. <br>

A **compiler** is a program (or collection of programs) that reads source code (typically written in a high-level language) and translates it into some other language (typically a low-level language, such as assembly or machine language, etc…). Over the years, compilers have become very good at producing fast, optimized code, and in some cases can do a better job than humans can in assembly language! <br> 

An **interpreter** is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. But **interpreter** must be installed on every machine where an interpreted program will be run. <br>

Studies have shown that only **20%** of a programmer’s time is actually spent writing the initial program. The other **80%** is spent on maintenance, which can consist of debugging

## Compiler
- Checks for error.
- Second, the compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. Every `.cpp` file generates `.b` or `.obj` file with same name.

## Linker
-  Linker reads in each of the **object files** generated by the compiler and makes sure they are valid.
-  Linker ensures all **cross-file dependencies** are resolved properly. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.
-   Linker also is capable of **linking library files**. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs.

## Build
For building process **make** or **build2** are used 

## Precompiled Headers
Generally comes as an option when we create a project. <br>
In large projects (those with many code files), precompiled headers can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects. <br>

However, precompiled headers require extra work to use, and for small projects (such as those you’ll create in our tutorials) make little to no difference in compilation times. <br>

> **Background** <br>
> When you create a new project in Visual Studio, a precompiled header file named **pch.h** is added to the project. (In Visual Studio 2017 and earlier, the file was called **stdafx.h**.) The purpose of the file is to speed up the build process. <br>
> Any stable header files, for example Standard Library headers such as <vector>, should be included here. The precompiled header is compiled only when it, or any files it includes, are modified. If you only make changes in your project source code, the build will skip compilation for the precompiled header.

[**StackOverFlow**](https://stackoverflow.com/questions/903228/why-use-precompiled-headers-c-c)
<br>In C/C++, the #include mechanism is a textual copy of the file specified into the current file. Headers include other headers (which include yet other headers), so when you do a #include, it could be adding tens of thousands of lines of C++ into each cpp file (or cxx, c, whatever), all of which need to be compiled each time. This can be a severe bottleneck for large projects. <br>

Precompiled headers speed this up by compiling each header once, then including that compiled state into the cpp they are included in. <br>

One important note on Visual Studio: make sure the first #include in each header is #include "stdafx.h". <br>

**Example Usage**

Your automation folder may required a lot of header files which need to be precompiled before your tests start running. 

**stdafx.h**
```
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

// Headers for CppUnitTest
#include <Windows.h>
#include "CppUnitTest.h"

#include "../../../Assets/API/model.engine/Jit__Stage.h"
#include "../../../Assets/API/model.engine/Base__Machine.h"
#include "../../../Assets/API/model.engine/Machine__Flags.h"
#include "../../../Assets/API/model.engine/Engine.h"
#include "../../../Assets/API/model.engine/Shared__Tags.h"
#include "../../../Assets/API/model.engine/Model__Builder.h"
#include "../../../Assets/API/model.engine/Active__Builder.h"
#include "../../../Assets/API/model.engine/Chamber__Actions.h"
#include "../../../Assets/API/model.engine/Json__Helper.h"

#include "gmock/gmock.h"
```

**stdafx.cpp**
```
// stdafx.cpp : source file that includes just the standard includes
// model.engine.Tests.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// The following lines pull in the real gmock *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-cardinalities.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-internal-utils.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-matchers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-spec-builders.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock.cc"

// The following lines pull in the real gtest *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gtest.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-death-test.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-filepath.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-port.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-printers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-test-part.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-typed-test.cc"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
```

Later you to **include** the `stadafx.h` in your mockfiles

```
#pragma once
#include "stdafx.h"
#include "../../../Assets/API/model.__engine/IBuildState__Manager.h"

namespace Cartman {
class MockBuildState__Manager : public IBuildState__Manager {		
public:

	MockBuildState__Manager() { };

	MOCK_METHOD(EPause__Condition, getPause__Condition, (), (const));

	MOCK_METHOD(EState, getCurrent__State, (), ());

	MOCK_METHOD(int, getRemaining__LayersToPause, (), (const));

	MOCK_METHOD(long long, getRemaining__AutoPauseTime, (), (const));

	MOCK_METHOD(void, update, (), ());
};	
```

NOTE: IF you checked the box for creating the precompiler header file and not included the pch.h/stdafx.h in your any of the source files then it will give error and **it should be top of all the headers in a file.**

## Compile, build, rebuild, clean

When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn’t been modified doesn’t need to be recompiled -- the cached object file from last time can be reused. This can speed up compilation times significantly (at the cost of a little bit of disk space). <br>

With that in mind, here’s what each of the options typically does: <br>

- **Build** compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
- **Clean** removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.
- **Rebuild** does a “clean”, followed by a “build”.

## Common C++ Problems

**Q: When compiling my program, I get a ‘no newline at end of file’ error** <br>
> The C++ standard requires that all source (.cpp) files end in a newline. It’s silly, but it is what it is. Go to the bottom of your source file(s), hit enter, save, and recompile

**Q: When I compile my program, I get a warning about "Cannot find or open the PDB file"** <br>
This is a warning, not an error, so it shouldn’t impact your program. However, it is annoying. To fix it, go into the Debug menu -> Options and Settings -> Symbols, and check “Microsoft Symbol Server”.

## Build Configuration

**General Settings**
- What the executable will be named
- What directories the IDE will look in for other code and library files
- Whether to keep or strip out debugging information
- How much to have the compiler optimize your program etc.

### Debug Confiuration
- This configuration turns off all optimizations
- Includes debugging information
- Makes your programs larger and slower
- The debug configuration is usually selected as the active configuration by default

### Release Configuration
 - This version is typically optimized for size and performance, and doesn’t contain the extra debugging information

**GCC/G++ Compiler**
Add `-ggdb` to the command line when debugging and `-O2 -DNDEBUG` for release builds. Use the former for now.

**Disable compiler extension - Visual Studio**
- To disable compiler extensions, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to **All Configurations**.
- Then, click C/C++ > Language tab, and set **Conformance mode to Yes (/permissive-)** (if it is not already set to that by default).
- For GCC/B++You can disable compiler extensions by adding the ```-pedantic-errors``` flag to the compile command line.

### Max warnings
Turn your warning levels up to the maximum, especially while you are learning. It will help you identify possible issues. These are disbaled by default by many compilers and IDEs<br>

**Visual Studio**
<br>
- To increase your warning levels, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to All Configurations.
- Then select C/C++ > General tab and set Warning level to Level4 (/W4).
- Note: Do not choose EnableAllWarnings (/Wall) or you will be buried in warnings generated by the C++ standard library
<br>

**Visual Studio disables signed/unsigned conversion warnings** by default, and those are useful, so if you are using Visual Studio 2019 or newer, let’s enable those <br>
- From C/C++ > Command Line tab, under Additional Options, add /w44365. This tells the compiler to enable signed/unsigned conversion warnings at warning level 4 (which you enabled above).
- From C/C++ > External Includes tab, set External Header Warning Level to Level3 (/external:W3). This tells the compiler to compile standard library headers at warning level 3 (instead of 4) so that compiling those headers doesn’t trigger this warning.

**GCC/G++ Users** <br>
Add the following flags to your command line: -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion

### Warning as Errors
Enable “Treat warnings as errors”. This will force you to resolve all issues causing warnings. <br>
- To treat warnings as errors, right click on your project name in the Solution Explorer window, then choose Properties
- From the Project dialog, first make sure the Configuration field is set to All Configurations
- Then select C/C++ > General tab and set Treat Warnings As Errors to Yes (/WX).
- For GCC/G++ users : Add the following flag to your command line: ```-Werror```

### Exporting Project Templates
- In Visual Studio, this option is available via Project -> Export Template. Select “Project template”, add a name and optional description (e.g. C++20 console application), and then click “Finish”.
- Next time you create a new project, you’ll see this template show up in your list of project templates.
- Once you create a new project with this template, it may not open any files. You can open up your .cpp file in the Solution Explorer window by going to Solution -> <Project Name> -> Source Files -> <template name>.cpp.

# Basics
- Programs typically terminate (finish running) after the last statement inside function main has been executed (though programs may abort early in some circumstances, or do some cleanup afterwards).
- When an executable program finishes running, the program sends a value back to the operating system in order to indicate whether it ran successfully or not. This particular return statement returns the value 0 to the operating system, which means “everything went okay!”
- The main memory in a computer is called **Random Access Memory** (often called **RAM** for short). When we run a program, the operating system loads the program into RAM
- An object with a name is called a **variable** . An instantiated object is sometimes called an **instance**.

## Storage 
Depending on the data segmentation that a particular processor follows, we have five segments:

- **Code Segment** - Stores only code, ROM
- **BSS** (or Block Started by Symbol) Data segment - Stores initialised global and static variables
- **Stack segment** - stores all the local variables and other informations regarding function return address etc
- **Heap segment** - all dynamic allocations happens here

Data BSS (or Block Started by Symbol) segment - stores uninitialised global and static variables.<br>
Note that the difference between the data and BSS segments is that the former stores initialized global and static variables and the later stores UNinitialised ones. <br>

**Every segment has a write protected region where all the constants are stored.** <br>

> For example: <br>
> - If I have a const int which is local variable, then it is stored in the write protected region of stack segment.
>  - If I have a global that is initialised const var, then it is stored in the data segment.
>  - If I have an uninitialised const var, then it is stored in the BSS segment...
>  - In the GCC compiler, on most machines, read-only variables, constants, and jump tables are placed in the text section.

## Types of Initilization

### Default Initilization
 Leaves a variable with an indeterminate value.
```
int a
```

### Copy / Implicit Initilization 
- Copy assignment copies the value on the right-hand side of the = operator to the variable on the left-hand side of the operator
- Copy initialization **had fallen out of favor** in modern C++ due to being **less efficient** than other forms of initialization for some complex types.
```
int width = 5; // copy initialization of value 5 into variable width
```

### Direct / Explicit Initialization
- When an initial value is provided inside parenthesis.
- Direct initialization was initially introduced to allow for more efficient initialization of complex objects
- Just like copy initialization, direct initialization **had fallen out of favor in modern C++**, largely **due to being superseded by list initialization**
- Direct initialization is also used when values are explicitly **cast to another type**
 
```
int width( 5 ); // direct initialization of value 5 into variable width
```

- One of the reasons direct initialization had fallen out of favor is because it makes it hard to differentiate variables from functions. For example:
```
int x();  // forward declaration of function x
int x(0); // definition of variable x with initializer 0
```

### List Initilization
- The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces

```
int width { 5 };    // direct list initialization of initial value 5 into variable width
int height = { 6 }; // copy list initialization of initial value 6 into variable height
int depth {};       // value initialization (see next section)
```
- List initialization was introduced to provide a more consistent initialization syntax (which is why it is sometimes called **uniform initialization** ) that works in most cases contrary to copy initilization and direct initilization
- list initialization is generally preferred over the other initialization forms because it works in most cases, it **disallows narrowing conversions** where as in direct or copy initilization it may to implicit conversions. 
```
int width { 4.5 }; // error: a number with a fractional value can't fit into an int
```
In the above given example list initilization throws error whereas in other cases it will grop the fraction part.

### Value or Zero Initilization
When a variable is initialized using **empty braces**, value initialization takes place
```
int x {};      // value initialization
std::cin >> x; // we're immediately replacing that value
```

### Unused Variables
Sometimes you may leave your variables unused intentionally and compilers give warnings or sometimes errors too,
In order to get over this one case use ```[[maybe_unused]]```

```
int main()
{
    [[maybe_unused]] double pi { 3.14159 };
    [[maybe_unused]] double gravity { 9.8 };
    [[maybe_unused]] double phi { 1.61803 };

    // the above variables will not generate unused variable warnings

    return 0;
}
```

## cout, cin, and endl
- We use `std::cout`, along with the **insertion operator (<<)**
- Insertion operator (<<) can be used multiple times in a single statement to **concatenate** (link together) multiple pieces of output
```
std::cout << "Hello" << " world!";
```

### std::cout is bufferred
Statements in our program request that output be sent to the console. However, that output is typically not sent to the console immediately. Instead, the requested output “**gets in line**”, and is stored in a region of memory set aside to collect such requests (called a buffer). Periodically, the buffer is flushed, meaning all of the data collected in the buffer is transferred to its destination (in this case, the console). <br><br>

This also means that if your program crashes, aborts, or is paused (e.g. for debugging purposes) before the buffer is flushed, any output still waiting in the buffer will not be displayed. <br>
Writing data to a buffer is typically fast, whereas transferring a batch of data to an output device is comparatively slow. <br>

### std::endl vs '\n'
The ‘\n’ character moves the cursor to the next line of the console, but doesn’t request a flush, so it will often perform better whereas std::endl works on buffer methodology

### std::cin 
**>>** is called **extraction operator** called in case if std::cin

```
int x{}; //It is a good practice to initialize a variable before being used
std::cin >> x;
```

## Uninitialized Variable
When a variable that is not initialized is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in that memory address. <br>

**Potential performance issue** <br>
Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.<br>

If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you’re overwriting those values anyway). <br>

You should always initialize your variables because the cost of doing so is minuscule compared to the benefit.

**Visual Studio Presetting** <br>
Visual Studio, will initialize the contents of memory to some **preset value** when you’re using a **debug build configuration**. This will not happen when using a release build configuration. Therefore, if you want to run the above program yourself, make sure you’re using a release build configuration.

## Keyword and convenstions :
- Underscores used for variables and intercaps used for functions.
- You should avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- A good rule of thumb is to make the length of an identifier proportional to how widely it is used . `i` vs 'count`

## Whitespacing and formatting
**Lines should not be too long** <br>
Typically, 80 characters has been the de facto standard for the maximum length a line should be. If a line is going to be longer, it should be split (at a reasonable spot) into multiple lines. <br> You can have extensions/plugin for **column guide** <br>

If a long line is split with an operator (eg. << or +), the operator should be placed at the beginning of the next line, not the end of the current line
```
std::cout << 3 + 4
    + 5 + 6
    * 7 * 8;
```

**One exception**: If you are working in someone else’s code base, adopt their styles. It’s better to favor consistency than your preferences.

## Operators 

### Arity
**Unary** : `-` is an example. '5' -> `-5` it flips the sign of the variable <br>
**Binary** : `+`, `<<`, `>>` uses two operaands to work over like `3+4` or s`td::cout << x`
**Ternary** : Requires 3 operands to operate like `?`
**Nullary** : like `throw`

### Precedence
- `operator+` and `operator*` return sum and product value
- `operator=` and `opearator<<` behave differently. `x = 5` returns x and `std::cout << 5` returns `std::cout`
- `x = y = 5` evaluates as `x = (y = 5)`. First `y = 5` assigns `5` to `y`. This operation then returns `y`, which can then be assigned to `x`
- `std::cout << "Hello " << "world"` evaluates as `(std::cout << "Hello ") << "world!"` . This first prints `"Hello "` to the console. This operation returns `std::cout`, which can then be used to print `"world!"` to the console as well.

## Expressions
```
int x{2+3};
```
The statement above can be translated as:
```
type identifier{Expression};
```

**Expression** is a sequence of literals, variables, operators and funtions calles that calculates a single value. Process of doing that is called **evaluation** and output is called **result** <br>

> std::cout << x evaluates to the object std::cout <br>
> This allows us to do things like std::cout << x << y << z and have it work properly. If operator<< returned nothing, then after x was output, it wouldn't know where to send y and z <br>

**Expression Statement** : These are statements that consists of an expression followed by a semicolor. E.g. `x = 5;` A return value is geenrated from it , here it is `x` but it is discarded since it is not used. <br>

## Best Practice
New programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add **one piece at a time**, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece. <br>


# Virtual Table
When a function contains virtual function than virtual table corresponding to that class is generated during compile time.

Let's look at virtual table of this class:

```class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n\n"; };

};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n\n"; };

};
```

Virtual table of Base class:
*BaseClass contains a virtual function func2().
When an object of BaseClass is created, it contains a hidden virtual pointer (vptr) that points to the vtable of BaseClass.*
```
BaseClass vtable:
---------------------
| 0: Address of func2() |
---------------------
```
Virtual table of Derived class:

*DerivedClass also contains a virtual function func2(), which overrides the same function in BaseClass. When an object of DerivedClass is created, it contains a vptr that points to the vtable of DerivedClass.*
```
DerivedClass vtable:
---------------------
| 0: Address of DerivedClass::func2() |
---------------------
```

When a class is polymorphic (contains virtual functions), the compiler creates a hidden pointer in each object of that class. This pointer, called the **virtual pointer (vptr)**, points to the vtable of the dynamic type of the object.

# Static vs Dynamic vs Reinterpret Cast

## Static Casting
Static casting is done when you know the data types already:
E.g. conversion of float to int. The type is known during compile time.

## Dynamic Casting
Dynamic casting is done when the classes involved in conversion have virtual function and their behaviour is known during run time.
Types : Upcasting - derived to parent case class, where loss of information happens
Downcasting : parent to derived class : information can be restored.

```
class Base {
    virtual void foo() {};
};

class Derived : public Base {
    void foo () {};
};

Base* basePtr = new Derived;	//Upcasting - Loss of Information
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);	//Downcasting - Retrieve back information

if (derivedPtr) {
    // Successfully casted
} else {
    // Cast failed
}
```

### Casting Failure

```
class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n"; };
};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n"; };
};

int main()
{
	BaseClass *base = new BaseClass();
	base->func2();
	//downcasting
	DerivedClass* derived = dynamic_cast<DerivedClass*>(base); 

	derived->func2();
	// *Casting fails*
}
```

The dynamic casting fails because, intially base pointer points to BaseClass object.
In the dynamic casting we are making DerivedClass pointer point to Base class object where it fails.

```
DerivedClass* derived = dynamic_cast<DerivedClass*>(base);
```
During Dynamic Casting, the casting checks if the object being pointed to (Base class here by base *) by a pointer(Derived Class pointer here) is an instance of Derived Class or not.


## Reinterpret_Cast
It doesn't work on the basis of polymorphic behavior like Dynamic casting does.

In the code below:
```
DerivedClass* derived = reinterpret_cast<DerivedClass*>(base);
```
reinterpret_cast takes the BaseClass pointer base and forcefully reinterprets the bits of its address as if they were a DerivedClass pointer.
**It simply creates a new pointer of the target type with the same memory address as the original pointer.**

Since derived is a DerivedClass pointer, the compiler expects a DerivedClass object with its own virtual function table (vtable).
However, the actual object doesn't have a vtable for DerivedClass. It only has the vtable for BaseClass.
When derived->func2(); is called, the compiler incorrectly looks up func2 in the DerivedClass vtable, but it finds the base class version instead.  

reinterpret_cast only changes the pointer's type, not the underlying object's layout or behavior.
It doesn't magically insert the missing derived class members or vtable into the BaseClass object.
Technically, attempting to call a derived class function on a BaseClass object using a reinterpret_cast pointer is undefined behavior in C++.

# Function Pointers

## Typedef
```
typedef return_type (*FunctionPtr)(parameter_types...);

typedef void (*MyFunctionPtr)();
```

## using 
```
using FunctionPtr = return_type (*)(parameter_types...);

using MyFunctionPtr = void (*)();
```

## std::function
```
using FunctionType = std::function<return_type(parameter_types...)>;

using MyFunctionType = std::function<void()>;
```

# C-Style enums vs Class Enums

## Intro
C-Style enums
```
enum Color {green, yellow, blue};

int main()
{
	std::cout << green; //works
}
```

Class enums
```
enum Class Color {green, yellow, blue};

int main()
{
	std::cout << green;	   //doesn't work
	std::cout << Color::green; //works
}
```

## Differences
enum classes are better in these many ways:

1. enum classes can be type specified
```
enum class Color : unsigned int {  // Enum class with underlying type specified
    Red = 1,
    Green,
    Blue };
```

2. enum values can be initialized
```
enum class Day {  // Enum class without specified underlying type
    Monday = 1,
    Tuesday,
    Wednesday };
```

# Functions
**A function call is an expression that tells the CPU to interrupt the current function and execute another function.** <br>
```
returnType Identifier {Functio body}
```
Our main function should return `0` to indicate that it ran normally, other values mean failure due to error throw. <br>

The C++ standard only defines the meaning of 3 status codes: `0`, `EXIT_SUCCESS`, and `EXIT_FAILURE`. `0` and `EXIT_SUCCESS` both mean the program executed successfully.  <br> EXIT_FAILURE means the program did not execute successfully. <br>

`EXIT_SUCCESS` and `EXIT_FAILURE` are preprocessor macros defined in the <cstdlib> header:
```
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE
int main(){
    return EXIT_SUCCESS;
}
```

The only exception to the rule that a value-returning function must return a value via a return statement is for function `main()`. The function `main()` will implicitly return the value `0` if no return statement is provided. <br>

## Parameters 
**A function parameter** is a variable used in the header of a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are **initialized with a value provided by the caller of the function**. <br>
```
int add(int x, int y){  //x and y are function parameters
    return x + y;
}
```
An **argument** is a value that is passed from the caller to the function when a function call is made:
```
doPrint(); // this call has no arguments
printValue(6); // 6 is the argument passed to function printValue()
add(2, 3); // 2 and 3 are the arguments passed to function add()
```
When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter (using **copy initialization ("=")**). <br>

in `add(2,3)` `2` is copied to `x` and `3` is copied to `y` via `x = 2` and `y = 3` <br>

Arguments are the expressions that get resolved before being passes <br>
```
add(1, multiply(2, 3)) //here multiply woul dbe resolved first
```
## Scope
Scope is property of an identifier <br>

## Temporary Objects
```
int getValueFromUser(){ 	
	int input{3};	
	return input; // return the value of input back to the caller
}

int main(){
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored in this called?
	return 0;
}
```

In the code above :
- `getValueFromUser()` returns the value stored in local variable `input` **back to the caller**
- caller receives a **copy of the value** so that it has a value it can use even after `input` is destroyed
- The return value is stored in a **temporary object**. This temporary object is then passed to `std::cout` to be printed
- Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier) an is destroyed after ```std::cout << getValueFromUser() << '\n'``` executes.
- In the case where a temporary object is used to initialize a variable, the **initialization happens before the destruction of the temporary**.
- In modern C++ (especially since C++17) this step is skipped, use the return value of `getValueFromUser()` to directly initialize the parameter of `operator<<`.

## Forward Declaration

 - A forward declaration or a function prototype allows us to tell the compiler about the **existence of an identifier before actually defining the identifier**
 - This way when compiler encouters a function call, having gone through forward declaration it will understand that we're making a correct function call even if doesn't know where is function defined.
 - It is helpful in a scenrio where **caller()** and **callee()** are in different file or for functions having **circular dependencies** like below.
 - In C++ we forward declare the variable/function with its **type and name without its definition**, so that we can use its body. Doing this save **unncessary compilation**.

_Example_
```
//someFile.hpp
class Class;
void f(Class object);
```

```
#include <iostream>

void funcA(); //Function prototype
void funcB();

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // this works because we forward declared add() above
    return 0;
}

void funcA() { funcB(); };
void funcB() { funcA(); };
```

The interdependent functions call can only be solved by forward declration.

## Function without body
```
int add(int x, int y); // forward declaration of add()

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```
In the code above, on compilation it will reach only upto object file creation case but would fail in linking as the **linker would not be able to find the definition of the declaration**. <br>

**One definition rule** : You can forward declare as many times as possible but definition can exist only once

## Calling  Conventions

[source] (https://www.geeksforgeeks.org/calling-conventions-in-c-cpp/) <br>

Generalization :
```
return_type calling_convention function_name {
    // statements
}
```

```
int __cdecl cdeclAdd(int a, int b);

int __stdcall stdcallAdd(int a, int b)  ;
  
int __fastcall fastcallAdd(int a, int b, int c, int d);
  
class Temp { 
public: 
    int __thiscall thiscallAdd(int a, int b) ;
}; 
```

Calling convetions decides: <br>
1. How arguments are passed on stack
2. Who will clear the stack : caller or callerr ?
3. What registers will be used and how

**__cdecl**  
- It is the **default** calling ocnvention
- **Caller** cleans the stack. i.e. m**ain()::result = cdeclAdd(1, 2);** clears the stack
- reates larger executables than __stdcall, because it requires each **function call to include stack cleanup code**. (optimiization scope)

**__stdcall**
- This is a **Microsoft-specific calling convention** used by Win32 API functions
- Callee cleans the stack.

**__fastcall**
- Callee cleans the stack

**__thiscall**
- It is the **default** calling convention used by methods inside a **class**
- Callee cleans the stack
- Since we pass **this** pointer as well, we cannot use this calling convention for non-member functions

## Declaration vs Definition
source is [here](https://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/)
- **Declaration** tells compiler about existense of a variable/function/symbol and it memory address and required storage may not be defined
- **Definition** tells the compiler about what the body of the variable/function/symbol contains and how much memory is required to store it
- In case of reference variables and pointers declarations along with definitions is necessary. In case of pointers they need to have a fixed memory independent of the memory type they are pointing to, in face in deferencing the pointer definition becomes important.

**Functions** <br>
```
int f();               // declaration
int f() { return 42; } // definition
```

**Variables** <br>
```
int x;		//both a declaration and definition
```
x in the case above is initialised with 0 via default constructor of int. <br>

**Separating Declaration and Definition for variables** <br>
```
extern int x; // declaration
int x = 42;   // definition
```

In C++, all definitions are declarations. Conversely, not all declarations are definitions. <br>

A declaration is sufficient to allow the compiler to ensure an identifier is being used properly. For example, when the compiler encounters function call `add(5, 6)`, if it has already seen the declaration for `add(int, int)`, then it can validate that add is actually a function that takes two int parameters. It does not need to have actually seen the definition for function add (which may exist in some other file). <br>

**Contradiction** <br>
There are a few cases where the compiler must be able to see a full definition in order to use an identifier (such as for template definitions and type definitions.

## One Definition Rule

 - **Within a file**, each function, variable, type, or template can only have one definition. Not applicable to functions defined inside different namespaces. Violating this can cause **redefinition error**
- **Within a program**, each function or variable can only have one definition. This rule exists because programs can have more than one file. Violating this can cause to show **Linker to issue a redefinition error**
- Types, templates, **inline** functions, and **inline** variables are allowed to have duplicate definitions in different files, so long as each definition is identical. Violating this will cause **undefined** behavior.

**What can go wrong ?**
Suppose you have a file.h where you have declared a **_global_ function** and also defined in the same file :
```
//file.h
int add(int, int);

int add (int a  int b) {
return a + b;
}
```

Now, you have included this in different files:
```
//A.cpp
#include <file.h>
add(3,5);

//B.cpp
#include <file.h>
add(5,6);

//C.cpp
#include <file.h>
add(6,7);
```

Since you have declared the function globally, you have exposesd it to the **Linker** and when compiled it will search for its definition and it will **see its definition multiple files** instead of one file and due to this it will through multiple redefinition error.

## Extern "C" and Name Mangling
[source](https://www.geeksforgeeks.org/extern-c-in-c/)

C++ does name mangling to all the function in order to **add information of the arguments with the function name**. <br>
```
int f(void) { return 1; }
//becomes this
int __f_v(void) { return 1; }
```

This technique helps to resolve _function overloading_. <br>

But this can be an issue in case we are trying to use C library inside C++ file as C++ compiler may mangle their function names too and since C doesn't support name mangling the C functions will give error.

For e.g.
```
int printf(const char* format, ...); // a C function
 
// Driver Code
int main()
{
    printf("GeeksforGeeks");
    return 0;
}
```
This wold give error as `printf` is mangled something like `__printf__char`  by C++ and `printf("Geeks...)` isn't able to find `printf` anymore. <br>
To avoid name mangling of C functions in C++ class we use **extern "C"** .
```
// CPP Program to demonstrate Extern "C"

extern "C" {
int printf(const char* format, ...);
}

// Driver Code
int main()
{
	printf("GeeksforGeeks");
	return 0;
}
```

## Multiple Files
Remember, compiler compiles each `.cpp` file individually and makes `.o` object files and not '.h` files. <br>

```
//main.cpp
#include <iostream>

int add(int x, int y); // needed so main.cpp knows that add() is a function defined elsewhere

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```
The compiler compiles the file above into `main.o`, sees the function declaration of ```int add(int x, int y);``` and validates it for `add(3,4)` makes the object file. Linker then then searches for the definition for the function symbol ```int add(int x, int y);``` and searches for the definition across the different object files. 
```
//add.cpp
int add(int x, int y) //this is a gloable definition
{
    return x + y;
}
```
- Linker finally finds the symbol definition in add.cpp which is a **global definition** and finally links for the object files and this program finally compiles error free to give output `7`.
- Also, The **same wouldn't work** if you had made the definition in a 'add.h' file and it doesn't get converted in object file and linker wouldn't be able to file it in any object file.
- Also, don't include `add.cpp` in the `main.cpp` file as linker would find multiple defitions of add() function in `add.o` and `main.o`

**Making the definition local using namespace:** <br>
We can break the linker from working by making the global definition local by using namespace:
```
namespace{
	int add(int x, int y)
	{
		return x + y;
	}
}
```
Now this function is **no more exposed to linker** and compiler would give linker error issue.
