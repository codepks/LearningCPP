# LearningCPP

# Introduction
The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86/x64 family, which you may be using) have instructions that can be a variable length. <br>

**Assemly language**, for e.g., ```mov al, 061h``` sits on top of Machine Language which is atleast readable and writable and is still used today when speed is critical. An **Assembler** converts Assembly langugage to Machine langugage. <br>
It is still not very portable. <br>

Much like assembly programs, programs written in high level languages must be translated into a format the computer can understand before they can be run. There are two primary ways this is done: **compiling and interpreting**. <br>

A **compiler** is a program (or collection of programs) that reads source code (typically written in a high-level language) and translates it into some other language (typically a low-level language, such as assembly or machine language, etc…). Over the years, compilers have become very good at producing fast, optimized code, and in some cases can do a better job than humans can in assembly language! <br> 

An **interpreter** is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. But **interpreter** must be installed on every machine where an interpreted program will be run. <br>

Studies have shown that only **20%** of a programmer’s time is actually spent writing the initial program. The other **80%** is spent on maintenance, which can consist of debugging

## Compiler
- Checks for error.
- Second, the compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. Every `.cpp` file generates `.b` or `.obj` file with same name.

## Linker
-  Linker reads in each of the **object files** generated by the compiler and makes sure they are valid.
-  Linker ensures all **cross-file dependencies** are resolved properly. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.
-   Linker also is capable of **linking library files**. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs.

## Build
For building process **make** or **build2** are used 

## Precompiled Headers
Generally comes as an option when we create a project. <br>
In large projects (those with many code files), precompiled headers can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects. <br>

However, precompiled headers require extra work to use, and for small projects (such as those you’ll create in our tutorials) make little to no difference in compilation times. <br>

> **Background** <br>
> When you create a new project in Visual Studio, a precompiled header file named **pch.h** is added to the project. (In Visual Studio 2017 and earlier, the file was called **stdafx.h**.) The purpose of the file is to speed up the build process. <br>
> Any stable header files, for example Standard Library headers such as <vector>, should be included here. The precompiled header is compiled only when it, or any files it includes, are modified. If you only make changes in your project source code, the build will skip compilation for the precompiled header.

[**StackOverFlow**](https://stackoverflow.com/questions/903228/why-use-precompiled-headers-c-c)
<br>In C/C++, the #include mechanism is a textual copy of the file specified into the current file. Headers include other headers (which include yet other headers), so when you do a #include, it could be adding tens of thousands of lines of C++ into each cpp file (or cxx, c, whatever), all of which need to be compiled each time. This can be a severe bottleneck for large projects. <br>

Precompiled headers speed this up by compiling each header once, then including that compiled state into the cpp they are included in. <br>

One important note on Visual Studio: make sure the first #include in each header is #include "stdafx.h". <br>

**Example Usage**

Your automation folder may required a lot of header files which need to be precompiled before your tests start running. 

**stdafx.h**
```
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

// Headers for CppUnitTest
#include <Windows.h>
#include "CppUnitTest.h"

#include "../../../Assets/API/model.engine/Jit__Stage.h"
#include "../../../Assets/API/model.engine/Base__Machine.h"
#include "../../../Assets/API/model.engine/Machine__Flags.h"
#include "../../../Assets/API/model.engine/Engine.h"
#include "../../../Assets/API/model.engine/Shared__Tags.h"
#include "../../../Assets/API/model.engine/Model__Builder.h"
#include "../../../Assets/API/model.engine/Active__Builder.h"
#include "../../../Assets/API/model.engine/Chamber__Actions.h"
#include "../../../Assets/API/model.engine/Json__Helper.h"

#include "gmock/gmock.h"
```

**stdafx.cpp**
```
// stdafx.cpp : source file that includes just the standard includes
// model.engine.Tests.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// The following lines pull in the real gmock *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-cardinalities.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-internal-utils.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-matchers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-spec-builders.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock.cc"

// The following lines pull in the real gtest *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gtest.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-death-test.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-filepath.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-port.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-printers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-test-part.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-typed-test.cc"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
```

Later you to **include** the `stadafx.h` in your mockfiles

```
#pragma once
#include "stdafx.h"
#include "../../../Assets/API/model.__engine/IBuildState__Manager.h"

namespace Cartman {
class MockBuildState__Manager : public IBuildState__Manager {		
public:

	MockBuildState__Manager() { };

	MOCK_METHOD(EPause__Condition, getPause__Condition, (), (const));

	MOCK_METHOD(EState, getCurrent__State, (), ());

	MOCK_METHOD(int, getRemaining__LayersToPause, (), (const));

	MOCK_METHOD(long long, getRemaining__AutoPauseTime, (), (const));

	MOCK_METHOD(void, update, (), ());
};	
```

NOTE: IF you checked the box for creating the precompiler header file and not included the pch.h/stdafx.h in your any of the source files then it will give error and **it should be top of all the headers in a file.**

## Compile, build, rebuild, clean

When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn’t been modified doesn’t need to be recompiled -- the cached object file from last time can be reused. This can speed up compilation times significantly (at the cost of a little bit of disk space). <br>

With that in mind, here’s what each of the options typically does: <br>

- **Build** compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
- **Clean** removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.
- **Rebuild** does a “clean”, followed by a “build”.

## Common C++ Problems

**Q: When compiling my program, I get a ‘no newline at end of file’ error** <br>
> The C++ standard requires that all source (.cpp) files end in a newline. It’s silly, but it is what it is. Go to the bottom of your source file(s), hit enter, save, and recompile

**Q: When I compile my program, I get a warning about "Cannot find or open the PDB file"** <br>
This is a warning, not an error, so it shouldn’t impact your program. However, it is annoying. To fix it, go into the Debug menu -> Options and Settings -> Symbols, and check “Microsoft Symbol Server”.

## Build Configuration

**General Settings**
- What the executable will be named
- What directories the IDE will look in for other code and library files
- Whether to keep or strip out debugging information
- How much to have the compiler optimize your program etc.

### Debug Confiuration
- This configuration turns off all optimizations
- Includes debugging information
- Makes your programs larger and slower
- The debug configuration is usually selected as the active configuration by default

### Release Configuration
 - This version is typically optimized for size and performance, and doesn’t contain the extra debugging information

**GCC/G++ Compiler**
Add `-ggdb` to the command line when debugging and `-O2 -DNDEBUG` for release builds. Use the former for now.

**Disable compiler extension - Visual Studio**
- To disable compiler extensions, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to **All Configurations**.
- Then, click C/C++ > Language tab, and set **Conformance mode to Yes (/permissive-)** (if it is not already set to that by default).
- For GCC/B++You can disable compiler extensions by adding the ```-pedantic-errors``` flag to the compile command line.

### Max warnings
Turn your warning levels up to the maximum, especially while you are learning. It will help you identify possible issues. These are disbaled by default by many compilers and IDEs<br>

**Visual Studio**
<br>
- To increase your warning levels, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to All Configurations.
- Then select C/C++ > General tab and set Warning level to Level4 (/W4).
- Note: Do not choose EnableAllWarnings (/Wall) or you will be buried in warnings generated by the C++ standard library
<br>

**Visual Studio disables signed/unsigned conversion warnings** by default, and those are useful, so if you are using Visual Studio 2019 or newer, let’s enable those <br>
- From C/C++ > Command Line tab, under Additional Options, add /w44365. This tells the compiler to enable signed/unsigned conversion warnings at warning level 4 (which you enabled above).
- From C/C++ > External Includes tab, set External Header Warning Level to Level3 (/external:W3). This tells the compiler to compile standard library headers at warning level 3 (instead of 4) so that compiling those headers doesn’t trigger this warning.

**GCC/G++ Users** <br>
Add the following flags to your command line: -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion

### Warning as Errors
Enable “Treat warnings as errors”. This will force you to resolve all issues causing warnings. <br>
- To treat warnings as errors, right click on your project name in the Solution Explorer window, then choose Properties
- From the Project dialog, first make sure the Configuration field is set to All Configurations
- Then select C/C++ > General tab and set Treat Warnings As Errors to Yes (/WX).
- For GCC/G++ users : Add the following flag to your command line: ```-Werror```

### Exporting Project Templates
- In Visual Studio, this option is available via Project -> Export Template. Select “Project template”, add a name and optional description (e.g. C++20 console application), and then click “Finish”.
- Next time you create a new project, you’ll see this template show up in your list of project templates.
- Once you create a new project with this template, it may not open any files. You can open up your .cpp file in the Solution Explorer window by going to Solution -> <Project Name> -> Source Files -> <template name>.cpp.

# Basics
- Programs typically terminate (finish running) after the last statement inside function main has been executed (though programs may abort early in some circumstances, or do some cleanup afterwards).
- When an executable program finishes running, the program sends a value back to the operating system in order to indicate whether it ran successfully or not. This particular return statement returns the value 0 to the operating system, which means “everything went okay!”
- The main memory in a computer is called **Random Access Memory** (often called **RAM** for short). When we run a program, the operating system loads the program into RAM
- An object with a name is called a **variable** . An instantiated object is sometimes called an **instance**.

## Storage 
Depending on the data segmentation that a particular processor follows, we have five segments:

- **Code Segment** - Stores only code, ROM
- **BSS** (or Block Started by Symbol) Data segment - Stores initialised global and static variables
- **Stack segment** - stores all the local variables and other informations regarding function return address etc
- **Heap segment** - all dynamic allocations happens here

Data BSS (or Block Started by Symbol) segment - stores uninitialised global and static variables.<br>
Note that the difference between the data and BSS segments is that the former stores initialized global and static variables and the later stores UNinitialised ones. <br>

**Every segment has a write protected region where all the constants are stored.** <br>

> For example: <br>
> - If I have a const int which is local variable, then it is stored in the write protected region of stack segment.
>  - If I have a global that is initialised const var, then it is stored in the data segment.
>  - If I have an uninitialised const var, then it is stored in the BSS segment...
>  - In the GCC compiler, on most machines, read-only variables, constants, and jump tables are placed in the text section.

## Types of Initilization

### Default Initilization
 Leaves a variable with an indeterminate value.
```
int a
```

### Copy / Implicit Initilization 
- Copy assignment copies the value on the right-hand side of the = operator to the variable on the left-hand side of the operator
- Copy initialization **had fallen out of favor** in modern C++ due to being **less efficient** than other forms of initialization for some complex types.
```
int width = 5; // copy initialization of value 5 into variable width
```

### Direct / Explicit Initialization
- When an initial value is provided inside parenthesis.
- Direct initialization was initially introduced to allow for more efficient initialization of complex objects
- Just like copy initialization, direct initialization **had fallen out of favor in modern C++**, largely **due to being superseded by list initialization**
- Direct initialization is also used when values are explicitly **cast to another type**
 
```
int width( 5 ); // direct initialization of value 5 into variable width
```

- One of the reasons direct initialization had fallen out of favor is because it makes it hard to differentiate variables from functions. For example:
```
int x();  // forward declaration of function x
int x(0); // definition of variable x with initializer 0
```

### List Initilization
- The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces

```
int width { 5 };    // direct list initialization of initial value 5 into variable width
int height = { 6 }; // copy list initialization of initial value 6 into variable height
int depth {};       // value initialization (see next section)
```
- List initialization was introduced to provide a more consistent initialization syntax (which is why it is sometimes called **uniform initialization** ) that works in most cases contrary to copy initilization and direct initilization
- list initialization is generally preferred over the other initialization forms because it works in most cases, it **disallows narrowing conversions** where as in direct or copy initilization it may to implicit conversions. 
```
int width { 4.5 }; // error: a number with a fractional value can't fit into an int
```
In the above given example list initilization throws error whereas in other cases it will grop the fraction part.

### Value or Zero Initilization
When a variable is initialized using **empty braces**, value initialization takes place
```
int x {};      // value initialization
std::cin >> x; // we're immediately replacing that value
```

### Unused Variables
Sometimes you may leave your variables unused intentionally and compilers give warnings or sometimes errors too,
In order to get over this one case use ```[[maybe_unused]]```

```
int main()
{
    [[maybe_unused]] double pi { 3.14159 };
    [[maybe_unused]] double gravity { 9.8 };
    [[maybe_unused]] double phi { 1.61803 };

    // the above variables will not generate unused variable warnings

    return 0;
}
```

## cout, cin, and endl
- We use `std::cout`, along with the **insertion operator (<<)**
- Insertion operator (<<) can be used multiple times in a single statement to **concatenate** (link together) multiple pieces of output
```
std::cout << "Hello" << " world!";
```

### std::cout is bufferred
Statements in our program request that output be sent to the console. However, that output is typically not sent to the console immediately. Instead, the requested output “**gets in line**”, and is stored in a region of memory set aside to collect such requests (called a buffer). Periodically, the buffer is flushed, meaning all of the data collected in the buffer is transferred to its destination (in this case, the console). <br><br>

This also means that if your program crashes, aborts, or is paused (e.g. for debugging purposes) before the buffer is flushed, any output still waiting in the buffer will not be displayed. <br>
Writing data to a buffer is typically fast, whereas transferring a batch of data to an output device is comparatively slow. <br>

### std::endl vs '\n'
The ‘\n’ character moves the cursor to the next line of the console, but doesn’t request a flush, so it will often perform better whereas std::endl works on buffer methodology

### std::cin 
**>>** is called **extraction operator** called in case if std::cin

```
int x{}; //It is a good practice to initialize a variable before being used
std::cin >> x;
```

## Uninitialized Variable
When a variable that is not initialized is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in that memory address. <br>

**Potential performance issue** <br>
Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.<br>

If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you’re overwriting those values anyway). <br>

You should always initialize your variables because the cost of doing so is minuscule compared to the benefit.

**Visual Studio Presetting** <br>
Visual Studio, will initialize the contents of memory to some **preset value** when you’re using a **debug build configuration**. This will not happen when using a release build configuration. Therefore, if you want to run the above program yourself, make sure you’re using a release build configuration.

## Keyword and convenstions :
- Underscores used for variables and intercaps used for functions.
- You should avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- A good rule of thumb is to make the length of an identifier proportional to how widely it is used . `i` vs 'count`

## Whitespacing and formatting
**Lines should not be too long** <br>
Typically, 80 characters has been the de facto standard for the maximum length a line should be. If a line is going to be longer, it should be split (at a reasonable spot) into multiple lines. <br> You can have extensions/plugin for **column guide** <br>

If a long line is split with an operator (eg. << or +), the operator should be placed at the beginning of the next line, not the end of the current line
```
std::cout << 3 + 4
    + 5 + 6
    * 7 * 8;
```

**One exception**: If you are working in someone else’s code base, adopt their styles. It’s better to favor consistency than your preferences.

## Operators 

### Arity
**Unary** : `-` is an example. '5' -> `-5` it flips the sign of the variable <br>
**Binary** : `+`, `<<`, `>>` uses two operaands to work over like `3+4` or s`td::cout << x`
**Ternary** : Requires 3 operands to operate like `?`
**Nullary** : like `throw`

### Precedence
- `operator+` and `operator*` return sum and product value
- `operator=` and `opearator<<` behave differently. `x = 5` returns x and `std::cout << 5` returns `std::cout`
- `x = y = 5` evaluates as `x = (y = 5)`. First `y = 5` assigns `5` to `y`. This operation then returns `y`, which can then be assigned to `x`
- `std::cout << "Hello " << "world"` evaluates as `(std::cout << "Hello ") << "world!"` . This first prints `"Hello "` to the console. This operation returns `std::cout`, which can then be used to print `"world!"` to the console as well.

## Expressions
```
int x{2+3};
```
The statement above can be translated as:
```
type identifier{Expression};
```

**Expression** is a sequence of literals, variables, operators and funtions calles that calculates a single value. Process of doing that is called **evaluation** and output is called **result** <br>

> std::cout << x evaluates to the object std::cout <br>
> This allows us to do things like std::cout << x << y << z and have it work properly. If operator<< returned nothing, then after x was output, it wouldn't know where to send y and z <br>

**Expression Statement** : These are statements that consists of an expression followed by a semicolor. E.g. `x = 5;` A return value is geenrated from it , here it is `x` but it is discarded since it is not used. <br>

## Best Practice
New programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add **one piece at a time**, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece. <br>


# Virtual Table
When a function contains virtual function than virtual table corresponding to that class is generated during compile time.

Let's look at virtual table of this class:

```class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n\n"; };

};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n\n"; };

};
```

Virtual table of Base class:
*BaseClass contains a virtual function func2().
When an object of BaseClass is created, it contains a hidden virtual pointer (vptr) that points to the vtable of BaseClass.*
```
BaseClass vtable:
---------------------
| 0: Address of func2() |
---------------------
```
Virtual table of Derived class:

*DerivedClass also contains a virtual function func2(), which overrides the same function in BaseClass. When an object of DerivedClass is created, it contains a vptr that points to the vtable of DerivedClass.*
```
DerivedClass vtable:
---------------------
| 0: Address of DerivedClass::func2() |
---------------------
```

When a class is polymorphic (contains virtual functions), the compiler creates a hidden pointer in each object of that class. This pointer, called the **virtual pointer (vptr)**, points to the vtable of the dynamic type of the object.

# Static vs Dynamic vs Reinterpret Cast

## Static Casting
Static casting is done when you know the data types already:
E.g. conversion of float to int. The type is known during compile time.

## Dynamic Casting
Dynamic casting is done when the classes involved in conversion have virtual function and their behaviour is known during run time.
Types : Upcasting - derived to parent case class, where loss of information happens
Downcasting : parent to derived class : information can be restored.

```
class Base {
    virtual void foo() {};
};

class Derived : public Base {
    void foo () {};
};

Base* basePtr = new Derived;	//Upcasting - Loss of Information
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);	//Downcasting - Retrieve back information

if (derivedPtr) {
    // Successfully casted
} else {
    // Cast failed
}
```

### Casting Failure

```
class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n"; };
};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n"; };
};

int main()
{
	BaseClass *base = new BaseClass();
	base->func2();
	//downcasting
	DerivedClass* derived = dynamic_cast<DerivedClass*>(base); 

	derived->func2();
	// *Casting fails*
}
```

The dynamic casting fails because, intially base pointer points to BaseClass object.
In the dynamic casting we are making DerivedClass pointer point to Base class object where it fails.

```
DerivedClass* derived = dynamic_cast<DerivedClass*>(base);
```
During Dynamic Casting, the casting checks if the object being pointed to (Base class here by base *) by a pointer(Derived Class pointer here) is an instance of Derived Class or not.


## Reinterpret_Cast
It doesn't work on the basis of polymorphic behavior like Dynamic casting does.

In the code below:
```
DerivedClass* derived = reinterpret_cast<DerivedClass*>(base);
```
reinterpret_cast takes the BaseClass pointer base and forcefully reinterprets the bits of its address as if they were a DerivedClass pointer.
**It simply creates a new pointer of the target type with the same memory address as the original pointer.**

Since derived is a DerivedClass pointer, the compiler expects a DerivedClass object with its own virtual function table (vtable).
However, the actual object doesn't have a vtable for DerivedClass. It only has the vtable for BaseClass.
When derived->func2(); is called, the compiler incorrectly looks up func2 in the DerivedClass vtable, but it finds the base class version instead.  

reinterpret_cast only changes the pointer's type, not the underlying object's layout or behavior.
It doesn't magically insert the missing derived class members or vtable into the BaseClass object.
Technically, attempting to call a derived class function on a BaseClass object using a reinterpret_cast pointer is undefined behavior in C++.

# Function Pointers

## Typedef
```
typedef return_type (*FunctionPtr)(parameter_types...);

typedef void (*MyFunctionPtr)();
```

## using 
```
using FunctionPtr = return_type (*)(parameter_types...);

using MyFunctionPtr = void (*)();
```

## std::function
```
using FunctionType = std::function<return_type(parameter_types...)>;

using MyFunctionType = std::function<void()>;
```

# C-Style enums vs Class Enums

## Intro
C-Style enums
```
enum Color {green, yellow, blue};

int main()
{
	std::cout << green; //works
}
```

Class enums
```
enum Class Color {green, yellow, blue};

int main()
{
	std::cout << green;	   //doesn't work
	std::cout << Color::green; //works
}
```

## Differences
enum classes are better in these many ways:

1. enum classes can be type specified
```
enum class Color : unsigned int {  // Enum class with underlying type specified
    Red = 1,
    Green,
    Blue };
```

2. enum values can be initialized
```
enum class Day {  // Enum class without specified underlying type
    Monday = 1,
    Tuesday,
    Wednesday };
```

# Functions
**A function call is an expression that tells the CPU to interrupt the current function and execute another function.** <br>
```
returnType Identifier {Functio body}
```
Our main function should return `0` to indicate that it ran normally, other values mean failure due to error throw. <br>

The C++ standard only defines the meaning of 3 status codes: `0`, `EXIT_SUCCESS`, and `EXIT_FAILURE`. `0` and `EXIT_SUCCESS` both mean the program executed successfully.  <br> EXIT_FAILURE means the program did not execute successfully. <br>

`EXIT_SUCCESS` and `EXIT_FAILURE` are preprocessor macros defined in the <cstdlib> header:
```
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE
int main(){
    return EXIT_SUCCESS;
}
```

The only exception to the rule that a value-returning function must return a value via a return statement is for function `main()`. The function `main()` will implicitly return the value `0` if no return statement is provided. <br>

## Parameters 
**A function parameter** is a variable used in the header of a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are **initialized with a value provided by the caller of the function**. <br>
```
int add(int x, int y){  //x and y are function parameters
    return x + y;
}
```
An **argument** is a value that is passed from the caller to the function when a function call is made:
```
doPrint(); // this call has no arguments
printValue(6); // 6 is the argument passed to function printValue()
add(2, 3); // 2 and 3 are the arguments passed to function add()
```
When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter (using **copy initialization ("=")**). <br>

in `add(2,3)` `2` is copied to `x` and `3` is copied to `y` via `x = 2` and `y = 3` <br>

Arguments are the expressions that get resolved before being passes <br>
```
add(1, multiply(2, 3)) //here multiply woul dbe resolved first
```
## Scope
Scope is property of an identifier <br>

## Temporary Objects
```
int getValueFromUser(){ 	
	int input{3};	
	return input; // return the value of input back to the caller
}

int main(){
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored in this called?
	return 0;
}
```

In the code above :
- `getValueFromUser()` returns the value stored in local variable `input` **back to the caller**
- caller receives a **copy of the value** so that it has a value it can use even after `input` is destroyed
- The return value is stored in a **temporary object**. This temporary object is then passed to `std::cout` to be printed
- Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier) an is destroyed after ```std::cout << getValueFromUser() << '\n'``` executes.
- In the case where a temporary object is used to initialize a variable, the **initialization happens before the destruction of the temporary**.
- In modern C++ (especially since C++17) this step is skipped, use the return value of `getValueFromUser()` to directly initialize the parameter of `operator<<`.

## Forward Declaration

 - A forward declaration or a function prototype allows us to tell the compiler about the **existence of an identifier before actually defining the identifier**
 - This way when compiler encouters a function call, having gone through forward declaration it will understand that we're making a correct function call even if doesn't know where is function defined.
 - It is helpful in a scenrio where **caller()** and **callee()** are in different file or for functions having **circular dependencies** like below.
 - In C++ we forward declare the variable/function with its **type and name without its definition**, so that we can use its body. Doing this save **unncessary compilation**.

_Example_
```
//someFile.hpp
class Class;
void f(Class object);
```

```
#include <iostream>

void funcA(); //Function prototype
void funcB();

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // this works because we forward declared add() above
    return 0;
}

void funcA() { funcB(); };
void funcB() { funcA(); };
```

The interdependent functions call can only be solved by forward declration.

## Function without body
```
int add(int x, int y); // forward declaration of add()

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```
In the code above, on compilation it will reach only upto object file creation case but would fail in linking as the **linker would not be able to find the definition of the declaration**. <br>

**One definition rule** : You can forward declare as many times as possible but definition can exist only once

## Calling  Conventions

[source] (https://www.geeksforgeeks.org/calling-conventions-in-c-cpp/) <br>

Generalization :
```
return_type calling_convention function_name {
    // statements
}
```

```
int __cdecl cdeclAdd(int a, int b);

int __stdcall stdcallAdd(int a, int b)  ;
  
int __fastcall fastcallAdd(int a, int b, int c, int d);
  
class Temp { 
public: 
    int __thiscall thiscallAdd(int a, int b) ;
}; 
```

Calling convetions decides: <br>
1. How arguments are passed on stack
2. Who will clear the stack : caller or callerr ?
3. What registers will be used and how

**__cdecl**  
- It is the **default** calling ocnvention
- **Caller** cleans the stack. i.e. m**ain()::result = cdeclAdd(1, 2);** clears the stack
- reates larger executables than __stdcall, because it requires each **function call to include stack cleanup code**. (optimiization scope)

**__stdcall**
- This is a **Microsoft-specific calling convention** used by Win32 API functions
- Callee cleans the stack.

**__fastcall**
- Callee cleans the stack

**__thiscall**
- It is the **default** calling convention used by methods inside a **class**
- Callee cleans the stack
- Since we pass **this** pointer as well, we cannot use this calling convention for non-member functions

## Declaration vs Definition
source is [here](https://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/)
- **Declaration** tells compiler about existense of a variable/function/symbol and it memory address and required storage may not be defined
- **Definition** tells the compiler about what the body of the variable/function/symbol contains and how much memory is required to store it
- In case of reference variables and pointers declarations along with definitions is necessary. In case of pointers they need to have a fixed memory independent of the memory type they are pointing to, in face in deferencing the pointer definition becomes important.

**Functions** <br>
```
int f();               // declaration
int f() { return 42; } // definition
```

**Variables** <br>
```
int x;		//both a declaration and definition
```
x in the case above is initialised with 0 via default constructor of int. <br>

**Separating Declaration and Definition for variables** <br>
```
extern int x; // declaration
int x = 42;   // definition
```

In C++, all definitions are declarations. Conversely, not all declarations are definitions. <br>

A declaration is sufficient to allow the compiler to ensure an identifier is being used properly. For example, when the compiler encounters function call `add(5, 6)`, if it has already seen the declaration for `add(int, int)`, then it can validate that add is actually a function that takes two int parameters. It does not need to have actually seen the definition for function add (which may exist in some other file). <br>

**Contradiction** <br>
There are a few cases where the compiler must be able to see a full definition in order to use an identifier (such as for template definitions and type definitions.

## One Definition Rule

 - **Within a file**, each function, variable, type, or template can only have one definition. Not applicable to functions defined inside different namespaces. Violating this can cause **redefinition error**
- **Within a program**, each function or variable can only have one definition. This rule exists because programs can have more than one file. Violating this can cause to show **Linker to issue a redefinition error**
- Types, templates, **inline** functions, and **inline** variables are allowed to have duplicate definitions in different files, so long as each definition is identical. Violating this will cause **undefined** behavior.

**What can go wrong ?**
Suppose you have a file.h where you have declared a **_global_ function** and also defined in the same file :
```
//file.h
int add(int, int);

int add (int a  int b) {
return a + b;
}
```

Now, you have included this in different files:
```
//A.cpp
#include <file.h>
add(3,5);

//B.cpp
#include <file.h>
add(5,6);

//C.cpp
#include <file.h>
add(6,7);
```

Since you have declared the function globally, you have exposesd it to the **Linker** and when compiled it will search for its definition and it will **see its definition multiple files** instead of one file and due to this it will through multiple redefinition error.

## Extern "C" and Name Mangling
[source](https://www.geeksforgeeks.org/extern-c-in-c/)

C++ does name mangling to all the function in order to **add information of the arguments with the function name**. <br>
```
int f(void) { return 1; }
//becomes this
int __f_v(void) { return 1; }
```

This technique helps to resolve _function overloading_. <br>

But this can be an issue in case we are trying to use C library inside C++ file as C++ compiler may mangle their function names too and since C doesn't support name mangling the C functions will give error.

For e.g.
```
int printf(const char* format, ...); // a C function
 
// Driver Code
int main()
{
    printf("GeeksforGeeks");
    return 0;
}
```
This wold give error as `printf` is mangled something like `__printf__char`  by C++ and `printf("Geeks...)` isn't able to find `printf` anymore. <br>
To avoid name mangling of C functions in C++ class we use **extern "C"** .
```
// CPP Program to demonstrate Extern "C"

extern "C" {
int printf(const char* format, ...);
}

// Driver Code
int main()
{
	printf("GeeksforGeeks");
	return 0;
}
```

## Multiple Files
Remember, compiler compiles each `.cpp` file individually and makes `.o` object files and not '.h` files. <br>

```
//main.cpp
#include <iostream>

int add(int x, int y); // needed so main.cpp knows that add() is a function defined elsewhere

int main(){
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```
The compiler compiles the file above into `main.o`, sees the function declaration of ```int add(int x, int y);``` and validates it for `add(3,4)` makes the object file. Linker then then searches for the definition for the function symbol ```int add(int x, int y);``` and searches for the definition across the different object files. 
```
//add.cpp
int add(int x, int y) //this is a gloable definition
{
    return x + y;
}
```
- Linker finally finds the symbol definition in add.cpp which is a **global definition** and finally links for the object files and this program finally compiles error free to give output `7`.
- Also, The **same wouldn't work** if you had made the definition in a 'add.h' file and it doesn't get converted in object file and linker wouldn't be able to file it in any object file.
- Also, don't include `add.cpp` in the `main.cpp` file as linker would find multiple defitions of add() function in `add.o` and `main.o`

**Making the definition local using namespace:** <br>
We can break the linker from working by making the global definition local by using namespace:
```
namespace{
	int add(int x, int y)
	{
		return x + y;
	}
}
```
Now this function is **no more exposed to linker** and compiler would give linker error issue.

## Namespaces

### Name Collision
```
//a.cpp:
#include <iostream>
void myFcn(int x){
    std::cout << x;
}
```
```
//main.cpp:
#include <iostream>
void myFcn(int x){
    std::cout << 2 * x;
}
int main() {
 return 0;
}
```
On compiling the code above, each individual file would compile properly but when it would come to Linker it would find duplication of defition of myFcn() (defition is also declration).

### Namespaces

The solution to above code is putting namespace to either of the definition to make the definition local to the file and then that defitniion can be accessed via namespace scope resolution. 
```
//main.cpp:
#include <iostream>
namespace SomeSpace{ void myFcn(int x){
    std::cout << 2 * x;
}
}
int main() {
SomeSpace::myFcn(3);
return 0;
}
```
Now defintions wouldn't collide as function defined inside namespace is not exposed to linker directly.

> **Notes** <br>
> Two identically named functions can be defined inside separate namespaces, and no naming collision will occur <br>
> Namespaces are often used to group related identifiers in a large project <br>
> You can only place declarations and definitions, not executable statements directly <br>
```
namespace MyNamespace {
  // OK: Variable declaration
  int myVariable;

  // OK: Function declaration
  void myFunction();

  // NOT OK: Executable statement directly within namespace
  x = 5; // This would cause a compiler error
}
```

### Global Namespace

```
//a.cpp:
#include <iostream>
void myFcn(int x){
    std::cout << x;
}
```

Here myFcn() is defined inside a global namespace. <br>

- Identifiers declared inside the global scope are in scope from the point of declaration to the end of the file.

### std namspace
- When you use an identifier that is defined inside a namespace (such as the std namespace), you have to tell the compiler that the identifier lives inside the namespace
- Use explicit namespace prefixes to access identifiers defined in a namespace.

```
#include <iostream> // imports the declaration of std::cout into the global scope
using namespace std; // makes std::cout accessible as "cout"
int cout() { // defines our own "cout" function in the global namespace
    return 5;
}

int main(){
    cout << "Hello, world!"; // Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?

    return 0;
}
```

The above code shows compiler here as cout defitnition is ambigous.

## Preprocessor
- Every code goes through preprocessing phase before compilation
- After preprocessing a file is called a **translation unit**

### Preprocessor Directives
- They are instructions that start with **#** and end with **newline**
- Preprosessor doesn't understand C++ syntax as it has its **own syntax**

### Macros
There are two types:
- Object-like macros - ``` #define DEBUG "debug" ```
- funtion-like macros - ```#define AREA(length, width) (length * width)```


They are more often seen in legacy code and have been replace with constant variables etc.

### Conditional Compilation

**#ifdef (#if defined() ), #ifndef (#if !defined()), and #endif** <br>
- The #ifdef preprocessor directive allows the preprocessor to check whether an identifier has been previously **#defined**. If so, the code between the #ifdef and matching #endif is compiled. If not, the code is ignored.
- #ifndef is the opposite of #ifdef, in that it allows you to check whether an identifier has NOT been #defined yet.

```
#define PRINT_JOE
int main(){
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n"; // will be excluded since PRINT_BOB is not defined
#endif
   return 0;
}
```
Only defined directive code will be compiled and others would be ignored

### #if 0
It can be used in a code to void from being compiled and it behave as if it is **inside a comment block**.

### Scope

```
void foo(){
#define MY_NAME "Alex"
}

int main(){
	std::cout << "My name is: " << MY_NAME << '\n';
	return 0;
}
```

- Preprocessor  doesn’t understand C++ concepts like functions.Therefore, this program behaves identically to one where #define MY_NAME “Alex” was defined either before or immediately after function foo()
- Directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.


```
// function.cpp
void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!\n";
#endif
#ifndef PRINT
    std::cout << "Not printing!\n";
#endif
}
```

```
// main.cpp
void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main(){
    doSomething();
    return 0;
}
```

The above program will print: <br>

**Not printing!**

## Header Files

The primary purpose of a header file is to **propagate declarations** to code (.cpp) files. <br>


```
//add.h:
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

```
//main.cpp:
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main(){
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

```
//add.cpp:
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
int add(int x, int y){
    return x + y;
}
```
In the code above the compiler still compiles well without adding add.h in add.cpp since it can find definition while linking process. 
 - By including its own header, add.cpp becomes a **self-sufficient module**. It can be used in other projects without requiring modifications to those projects' header files.
 - Including the header guarantees that the function's declaration and definition precisely match

```
// something.h:
int something(int); // return type of forward declaration is int
```
```
//something.cpp:
#include "something.h"
void something(int) // error: wrong return type
{
}
```

Including something.h in something.cpp would help to check if the declarations and definitions are matching or not and this we can get verified while compiling the individual source file something.cpp itself insted of jumping to compiling whole source code.

### Other Dir headers
The below given code shows bad practice to include headers in your file, know as **relative path to the header file**  :
```
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

Downsides to it <br>
1.  It requires you to reflect your directory structure in your code
2.  If you ever update your directory structure, your code won’t work anymore

**Better Method** <br>
A better method is to tell your compiler or IDE that you have a bunch of header files in some other location, so that it will look there when it can’t find them in the current directory. E.g. **Include Directories** in Visual Studio

### Include necessary headers
The best practice says that if your file requires a header <someheader> but that is already included by some other header <otherheader> which already includes <someheader> and you feel no need to include the <someheader> explicitly then you should't do so. <br>
If something goes wrong with <otherheader> then you would lose <someheader> as well, that's why you should explicity include <someheader> file too if it is required.

### Order of headers
It can matter if there is a dependency of declrations for e.g. header A depending on header B, then B shuold be included first then A.

**Best Practice** 
1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

## Header Guards

```
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```
Including header guards in your header file prevents your code from having mulitple copies of definitions / declarations(although multiple declarations is allowed) / **classes** etc. <br>

It is always good to have unique header guard names to avoid conflict of same name header file in a large project.

## pragma once
It serves the same purpose as header guards but complex cases header guards is still preferable over pragma once and it is followed by Google too.<br>
#pragma once is **not defined by the C++ standard**, it is possible that some compilers may not implement it.

## Design your first Program
1. Design step 1: Define your goal
2. Design step 2: Define requirements
3. Design step 3: Define your tools, targets, and backup plan
4. Design step 4: Break hard problems down into easy problems
5. Design step 5: Figure out the sequence of events

### Implementation
1. Outline your cod ein main function
```
int main()
{
//    doBedroomThings();
//    doBathroomThings();
//    doBreakfastThings();
//    doTransportationThings();

    return 0;
}
```

2. Implement each function
```
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
```

# Debugging

- First step is th reproduce the problem
- Comment your code
- OR Validate your code flow/do a DRY run
- Print the values
- Use `std:cerr` over `std::cout` as cout is more bufferred and cerr is not as it imidiately outputs the value. Cout may or may not show output in case of crash but `cerr` does. On the other hand, `std::cerr` is unbuffered, which means anything you send to it will output immediately

## Advance debugging

### Conditional Compilation
```
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
```
- If this were a multi-file program, the `#define ENABLE_DEBUG` would go in a header file that’s included into all code files so we can comment / uncomment the #define in a single location and have it propagate to all code files.
- Another downside of this approach is that if you make a typo (e.g. misspell “DEBUG”) or forget to include the header into a code file, some or all of the debugging for that file may not be enabled. `

## Logger
One can use one of the many existing third-party logging tools available

```
#include <plog/Log.h> // Step 1: include the logger headers
#include <plog/Initializers/RollingFileInitializer.h>
#include <iostream>

int getUserInput(){
	PLOGD << "getUserInput() called"; // PLOGD is defined by the plog library

	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main(){
	plog::init(plog::debug, "Logfile.txt"); // Step 2: initialize the logger
	PLOGD << "main() called"; // Step 3: Output to the log as if you were writing to the console
	int x{ getUserInput() };
	std::cout << "You entered: " << x << '\n';

	return 0;
}
```

# Fundamental Data Types

## Introduction
- Bit is a smallest unit of a data
- In modern computer architectures, each bit does not get its own unique memory address.Instead they are stored in chunks of data and collective bits or int + bits can have unique memory address, it is **1 byte of chunk** in C++ 
- Many of the types defined in newer versions of C++ (e.g. std::nullptr_t) use a **_t suffix**. This suffix means “**type**”

## Void

- It means no datatype
- The compiler knows about the existence of such types, but **does not have enough information to determine how much memory to allocate** for objects of that type
- `void` is intentionally incomplete since it represents the lack of a type, and thus cannot be defined

```
void value; // won't work, variables can't be defined with incomplete type void
```

**Usage** <br>
- `void` is used to indicate that a function does not return a value
- In C, void is used as a way to indicate that a function does not take any parameters
```
int getValue(void) // void here means no parameters
{
    int x{};
    std::cin >> x;

    return x;
}
```
- Void has more advance usage in form of **void pointers**

## size of objects
The sizeof operator is a unary operator that **takes either a type or a variable**, and returns its size in bytes <br>
NOTE : **sizeof** does not include dynamically allocated memory used by an object.

## signed integers
- In binary representation, **a single bit** (called the sign bit) is used to store the sign of the number
- The **non-sign bits** (called the magnitude bits) determine the magnitude of the number

### Range
- 8-bit integer contains 8 bits. 28 is 256, so an 8-bit integer can hold **256** possible values. There are 256 possible **values between -128 to 127**
- Out of 8 bits 1 bit is used to store the sign and rest 7 bits are used to store the magnitude
- Assigning value more than range can lead to **overflow** and undefined behaviour

Overflow case :
```
#include <iostream>

int main()
{
    // assume 4 byte integers
    int x { 2'147'483'647 }; // the maximum value of a 4-byte signed integer
    std::cout << x << '\n';

    x = x + 1; // integer overflow, undefined behavior
    std::cout << x << '\n';

    return 0;
}
```
output is 
```
2147483647
-2147483648
```
### Division
When doing division with two integers (called integer division), C++ always produces an integer result

## Unsigned Integers
Unsigned integers are integers that can only hold non-negative whole numbers. <br>

### Overflow
**If an unsigned value is out of range, it is divided by one greater than the largest number of the type, and only the remainder kept.** <br>

E.g. The number 280 is too big to fit in our 1-byte range of 0 to 255. 1 greater than the largest number of the type is 256. Therefore, we **divide 280 by 256, getting 1 remainder 24**. The remainder of 24 is what is stored. <br>

Any number bigger than the largest number representable by the type simply “**wraps around**” (sometimes called “modulo wrapping”) <br>

**Positive Wrapping**
If +ve value of greater than range is added then it gets truncated

**Negative Wrapping**
If -ve value is entered against the unsigned number **it wraps around to the top of the range**. <br>
E.g. In a 2-byte unsigned integer, -1 is not representable, so it wraps around to the top of the range, producing the value 65535. -2 wraps around to 65534. 

### Avoiding Unsigned Integers
1. It can easily introduce overflow in case of **subtraction** and **loops** having continous decrement
```
int main(){
	unsigned int x{ 2 };
	unsigned int y{ 3 };

	std::cout << x - y << '\n'; // prints 4294967295 (incorrect!)

	return 0;
}
```
```
Output : 4294967295 <br>
```

2. In C++, if a mathematical operation (e.g. arithmetic or comparison) has one signed integer and one unsigned integer, the **signed integer will usually be converted to an unsigned integer**
```
int main()
{
	unsigned int u{ 2 };
	signed int s{ 3 };

	std::cout << u - s << '\n'; // 2 - 3 = 4294967295

	return 0;
}
```

### When to use?
1.  unsigned numbers are preferred when dealing with **bit manipulation**
2.  useful in some algorithms like encryption and random number generation
3.  use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing
4.  If you’re developing for an embedded system use of unsigned numbers is more common and accepted for performance reasons.

## Fixed Width Integers
**Why ?** 
C opted to intentionally leave the size of an integer open so that the compiler implementers could pick a size for int that performs best on the target computer architecture. <br>

**C99** defined a set of fixed-width integers (in the stdint.h header) that are guaranteed to be the same size on any architecture.
> E.g. **std::int16_t** with range **-32,768 to 32,767** <br>

They are available under `<cstdint>`<br>

### Downsides
**First**, Your program will fail to compile on any such architecture that does not support a fixed-width integer that your program is using. However, given that most modern architectures have standardized around 8/16/32/64-bit variables, this is unlikely to be a problem <br>

**Second**, if you use a fixed-width integer, it may be slower than a wider type on some architectures. or example, if you need an integer that is guaranteed to be 32-bits, you might decide to use std::int32_t, but your CPU might actually be faster at processing 64-bit integers.

NOTE : When storing integral values where a specific size is important, it’s generally best to **avoid std::int8_t and std::uint8_t.**

### Best Practice
1. Prefer int when the size of the integer doesn’t matter
2. Prefer std::int#_t when storing a quantity that needs a guaranteed range
3. Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required

### std::size_t
```
std::cout << sizeof(int) << '\n';
```
The return value of sizeof is an size_t and its capacity is 4 bytes and with this it limits the maximum size of object to be 2^32

## Float type
- When using floating point literals, always **include at least one decimal place** (even if the decimal is 0). This helps the compiler understand that the number is a floating point number and not an integer
- Floating point literals default to type double. An f suffix is used to denote a literal of type float

```
int x{5};      // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
```

 NOTE : A 4 bytes floating type variable has 6-9 singnificant digits. <br>

 ### Override Precision
 We can override the default precision that std::cout shows by using an output manipulator function named **std::setprecision()**. Output manipulators alter how data is output, and are defined in the iomanip header. <br>

### Best Practice 
Favor **double over float** unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.

### Nan and Inf
- **Inf**, which represents infinity. Inf can be positive or negative
- **NaN**, which stands for “Not a Number”

```
double zero {0.0};
double posinf { 5.0 / zero }; // positive infinity
std::cout << posinf << '\n';

double neginf { -5.0 / zero }; // negative infinity
std::cout << neginf << '\n';

double nan { zero / zero }; // not a number (mathematically invalid)
std::cout << nan << '\n';
```
OUTPUT:
```
1.#INF
-1.#INF
1.#IND
```

## Boolean Values
```
bool isEqual(int x, int y)
{
    return x == y; // operator== returns true if x equals y, and false otherwise
}
```
`operator==` is a binary operator that inputs two values, here its `x` and `y` and return bool value.

In boolean value `false` is as `0` is inte
## Chars
The char data type was designed to hold a **single character** <br>
A character can be a single letter('A'), number (1), symbol(#), or whitespace(` `) <br>

- The **integer** stored by a char variable is intepreted as an **ASCII** character
- Character literals are always placed between **single quotes** (e.g. ‘g’, ‘1’, ‘ ‘)
- Codes 0-31 are called the unprintable chars
- Codes 32-127 are called the printable characters
- This way all the 0-127 value range is utilized in 8 bit character datatype except for negative value range

```
char ch2{ 'a' }; // initialize with code point for 'a' (stored as integer 97) (preferred)
char ch{5}; // initialize with integer 5 (stored as integer 5)
char ch{'5'}; // initialize with code point for '5' (stored as integer 53)

char ch2{ 98 }; // code point for 'b' (not preferred)
std::cout << ch2; // cout prints a character ('b')
```

**std::cin is a buffered input** <br>
```
std::cout << "Input a keyboard character: "; // assume the user enters "abcd" (without quotes)

char ch{};
std::cin >> ch; // ch = 'a', "bcd" is left queued.
std::cout << "You entered: " << ch << '\n';

// Note: The following cin doesn't ask the user for input, it grabs queued input!
std::cin >> ch; // ch = 'b', "cd" is left queued.
std::cout << "You entered: " << ch << '\n';
```
### Single Quote vs double quotes
Single chars are always put in **single quotes** to represent one symbol. <br>
Text between **double quotes** (e.g. “Hello, world!”) is treated as a string of multiple characters <br>

### Unicode
The most well-known mapping outside of ASCII is the Unicode standard, which maps over 144,000 integers to characters in many different languages. Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called UTF-32). However, Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called UTF-16 and UTF-8 respectively).

### wchar_t, char8_t, char16_t, and char32_t
**wchar_t** should be avoided in almost all cases (except when interfacing with the Windows API). Its size is implementation defined, and is not reliable. It has largely been deprecated. <br>
You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible. <br>

## Type Conversion
When the compiler does type conversion on our behalf without us explicitly asking, we call this **implicit type conversion** <br>

### Implicit Conversions
```
void print(double x){
	std::cout << x << '\n';
}

int main(){
	int y { 5 };
	print(y); // y is of type int
}
```
**Safe type conversion** : The conversion does not change variable `y` from type int to double. Instead, the conversion uses the value of `y` (5) as input to create a new double value (5.0). This double value is then passed to function print via **direct initilization** .<br>
**Unsafe TYpe Conversion** :In opposite case of converting 5.5 to 5 i.e double to int might show data loss warning. 

### Explicit Conversions
The variable itself is not affected by casting its value to a new type <br>
**For Removing Warning**
```
void print(int x){
	std::cout << x << '\n';
}

int main(){
	print( 5.5 ); // explicitly convert double value 5.5 to an int
	return 0;
}
```

The above code will give warning over type conversion from float to int leading to data loss. <br>
In order to remove the warning and telling the compiler that the conversion is explicit we need to use `static_cast`

```
print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int
```

**For static cast character to value**

```
int main(){
    char ch{ 97 }; // 97 is ASCII code for 'a'
    std::cout << ch << " has value " << static_cast<int>(ch) << '\n'; // print value of variable ch as an int

    return 0;
}
```
This outpurs:
```
a has value 97
```

**Converting unsigned numbers to signed numbers**
```
unsigned int u { 5 };
int s { static_cast<int>(u) }; // return value of variable u as an int
```

But if the input value is out of range for int then it will give undefined behaviour <br>



# Constants and Strings

## Constant Variables
2 types:
1. **Named contants** : associated with an identifier. E.g. Constant variables, Constant variables, Enumerated constants 
2. **Literal constants** : not associated with an identifier

## Named Constants
It is preferred to have constant **before type**: 
```
const double gravity { 9.8 };  // preferred use of const before type
int const sidesInSquare { 4 }; // "east const" style, okay but not preferred
```

Const variables **must** always be **initialized** :
```
const double gravity; // error: const variables must be initialized
gravity = 9.9;        // error: const variables can not be changed
int age{5};
const int constAge {  age }; //They can be initilized with non-const variables
```
### Constant Function Parameters
Making a function parameter constant enlists the compiler’s help to ensure that the parameter’s value is not changed inside the function.
```
void printInt(const int x){
    std::cout << x << '\n';
}
```
```
printInt(5); // 5 will be used as the initializer for x
```
NOTE : **Don’t use const when passing by value.** Anyway the constant variable would be destroyed and there is not point if passed by value and we have made it a constant. _const is preferred in pass by reference generally_

### Cost return values
```
const int getValue(){
    return 5;			// we are returning by value over here
}
```
For **fundamental types**, the const qualifier on a return type is simply ignored (your compiler may generate a warning). <br>
For other types, **return by value for constant variables is not a good practice** and it can interfere with compiler's optimization(**move semantics**) for non-const return by value. <br>

### contant variables over macros
- Macros cannot be scoped unlike constants as it is handled separately by preprocessor
- They don't have C++ syntax so it is difficult to debug them and it is difficult to inspect their value
```
void someFcn() {
// Even though gravity is defined inside this function
// the preprocessor will replace all subsequent occurrences of gravity in the rest of the file
#define gravity 9.8
}

void printGravity(double gravity) { // including this one, causing a compilation error
    std::cout << "gravity: " << gravity << '\n';
}
```
Use:
```
const int MAX_VALUE = 100;
```

## Multifile code
We declare them once in a central location and use them wherever needed. That way, if you ever need to change them, you only need to change them in one place. <br>
This can be well facilitate using **inline variables**.

## Literal contants
Literals are values that are **inserted directly into the code.** <br>
```
return 5;                     // 5 is an integer literal
bool myNameIsAlex { true };   // true is a boolean literal
double d { 3.4 };             // 3.4 is a double literal
std::cout << "Hello, world!"; // "Hello, world!" is a C-style string literal
```

### Literal suffixes
one can have literal suffixes like `f` to suggest the type of literal. `f` is used for a floating value. <br>
It is often used for **type deduction** too using auto keyword. <br>

This may cause warning <br>
```
float f { 4.1 }; // warning: 4.1 is a double literal, not a float literal
float f {4.1f} 	 //this works
```

### String Literals
- They are not fundamental to C++ and have a strange and complicated type that is hard to work with
- For this reasons they are known as **C-Style** strings
- They have null termination `'\0'`
- "Hello" has type `const char[6]` and not `const char[5]` due to null terminator

C-style string literals are const objects that are created at the start of the program and are guaranteed to **exist for the entirety of the program**.

## Numeral Systems
There are **4 main numeral systems** available in C++. In order of popularity, these are: 
1. decimal (base 10)
2. binary (base 2)
3. hexadecimal (base 16)
4. octal (base 8).

### Hexadecimal Literals
```
int x{ 0xF }; // 0x before the number means this is hexadecimal
```
**Binary Repesentation**
Because there are 16 different values for a hexadecimal digit, we can say that a **single hexadecimal digit encompasses 4 bits**. <br> **(00) is a byte**
```
32-bit integer : 0011 1010 0111 1111 1001 1000 0010 0110
hex value : 3A7F 9826
```

It is often used to represent memory addresses.

## Binary Literals 
```
bin = 0x0001; //before C++14
bin = 0b1;   //after C++14
```

### Digit separators
```
int bin { 0b1011'0010 };
long value { 2'132'673'462 };
```
separator can not occur before the first digit of the value:
```
int bin { 0b'1011'0010 };  // error: ' used before first digit of value
```

### Bitset
Doing output of binary literal in `std::cout`  a little difficult, we can use `biset` to store those literals and then output them:
```
std::bitset<8> bin1{ 0b1100'0101 };
```
C++ onwards std::format is also used:
```
std::cout << std::format("{:b}\n", 0b1010);  // C++20
```

## Constant Expressions
The **as-if** rule says that the compiler can modify a program however it likes in order to produce more optimized code, so long as those modifications do not affect a program’s “observable behavior” <br>

### Compile Time Evaluation
```
int x { 3 + 4 };
std::cout << x << '\n';
```

In the code above,  if not optimized compiler would have to **generate an executable that calculates** the result of `3 + 4`, if theis calculation is performed million times then it would lead to resource waster. <br>
To avoid this the compiler optimizes the `3+4` expression at the compile time itself and save the run time resource wastage. 
```
int x {7};
std::cout << x << '\n';
```
Although, this might make the compile time longer. These opimizations are one of the strong features of modern C++. 

### Constant Expressions

A constant expression contains on **compile time constants** and  **operators/functions** that support compile time evaluation. <br>

Examples of Compile time constants
1. Literals (e.g. ‘5’, ‘1.2’)
2. Constexpr variables
3. Const integral variables `const int x { 5 }`. We don't include **runtime constants** here : **const int x{value}**
5. Non-type template parameters
6. Enumerators 

**NOTE**: If you need runtime constant variables to be compile-time constants, define them as _constexpr variables_ instead. <br>

### Compile time vs run time const
**Compile Time constant**
```
const int c { 5 };           // 5 is a constant expression
const int d { c };           // c is a constant expression
const long e { c + 2 };      // c + 2 is a constant expression
```
Constant expressions **are always eligible for compile-time evaluation**, meaning they are more likely to be optimized at compile-time.
<br>
**Run time constant** <br>
```
int a { 5 };                 // 5 is a constant expression
double b { 1.2 + 3.4 };      // 1.2 + 3.4 is a constant expression

const int f { a };           // a is not a constant expression
const int g { a + 1 };       // a + 1 is not a constant expression
const long h { a + c };      // a + c is not a constant expression
const int i { getNumber() }; // getNumber() is not a constant expression
```
These may or may not have compile time optimization. <br>

**Runtime constant optimization** <br>
```
int x { 7 };            // x is non-const
std::cout << x << '\n'; // x is a non-constant subexpression
```

A smart compiler might realize that `x` will always evaluate to `7` in this particular program and it will optimize this under as-if rule. So it will remove x variable completely and replace next line `x` with `7`.

```
std::cout << 7 << '\n';
```

Had it been ```const int x {7}```, the compiler would have optmized it anyway.

> Order of optimization for compiler is
> - Compile-time constant variables (always eligible to be optimized)
> - Runtime constant variables
> - Non-const variables (likely optimized in simple cases only)

### Debugging Issue
Due to variable removal in optimization, the variables are often skipped while debugging. <br>
But debugger these days have optimizations turned off.

## Constexpr Variables
In some cases it is difficult to to gues for a compiler if the expression is a run time or compiler time constant:
```
const int d { obj };        // not obvious whether this is a runtime or compile-time const
const int e { getValue() }; // not obvious whether this is a runtime or compile-time const
```

In order to help with this, we utilize compilers power to hint us with constant expression by using **constexpr keyword**. <br>

A constexpr keyword **must** always be initilized with constant expression. These statements would be evaluated at compile time<br>
```
constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
constexpr int something { sum };  // ok: sum is a constant expression
```
Where is doesn't work:
Example 1 :
```
int age{};
std::cin >> age;
constexpr int myAge { age };      // compile error: age is not a constant expression
```
Example 2:
```
int five(){  return 5;}
constexpr int f { five() };       // compile error: return value of five() is not a constant
```
This will not work as five() is not a constant. To resolve this we need to make five() constexpr too.
```
constexpr int five(){  return 5;}
constexpr int f { five() };       // compile error: return value of five() is not a constant
```
