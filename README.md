# LearningCPP

# Introdcution
The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86/x64 family, which you may be using) have instructions that can be a variable length. <br>

**Assemly language**, for e.g., ```mov al, 061h``` sits on top of Machine Language which is atleast readable and writable and is still used today when speed is critical. An **Assembler** converts Assembly langugage to Machine langugage. <br>
It is still not very portable. <br>

Much like assembly programs, programs written in high level languages must be translated into a format the computer can understand before they can be run. There are two primary ways this is done: **compiling and interpreting**. <br>

A **compiler** is a program (or collection of programs) that reads source code (typically written in a high-level language) and translates it into some other language (typically a low-level language, such as assembly or machine language, etc…). Over the years, compilers have become very good at producing fast, optimized code, and in some cases can do a better job than humans can in assembly language! <br> 

An **interpreter** is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. But **interpreter** must be installed on every machine where an interpreted program will be run. <br>

Studies have shown that only **20%** of a programmer’s time is actually spent writing the initial program. The other **80%** is spent on maintenance, which can consist of debugging

## Compiler
- Checks for error.
- Second, the compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. Every `.cpp` file generates `.b` or `.obj` file with same name.

## Linker
-  Linker reads in each of the **object files** generated by the compiler and makes sure they are valid.
-  Linker ensures all **cross-file dependencies** are resolved properly. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.
-   Linker also is capable of **linking library files**. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs.

## Build
For building process **make** or **build2** are used 

## Precompiled Headers
Generally comes as an option when we create a project. <br>
In large projects (those with many code files), precompiled headers can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects. <br>

However, precompiled headers require extra work to use, and for small projects (such as those you’ll create in our tutorials) make little to no difference in compilation times. <br>

> **Background** <br>
> When you create a new project in Visual Studio, a precompiled header file named **pch.h** is added to the project. (In Visual Studio 2017 and earlier, the file was called **stdafx.h**.) The purpose of the file is to speed up the build process. <br>
> Any stable header files, for example Standard Library headers such as <vector>, should be included here. The precompiled header is compiled only when it, or any files it includes, are modified. If you only make changes in your project source code, the build will skip compilation for the precompiled header.

[**StackOverFlow**](https://stackoverflow.com/questions/903228/why-use-precompiled-headers-c-c)
<br>In C/C++, the #include mechanism is a textual copy of the file specified into the current file. Headers include other headers (which include yet other headers), so when you do a #include, it could be adding tens of thousands of lines of C++ into each cpp file (or cxx, c, whatever), all of which need to be compiled each time. This can be a severe bottleneck for large projects. <br>

Precompiled headers speed this up by compiling each header once, then including that compiled state into the cpp they are included in. <br>

One important note on Visual Studio: make sure the first #include in each header is #include "stdafx.h". <br>

**Example Usage**

Your automation folder may required a lot of header files which need to be precompiled before your tests start running. 

**stdafx.h**
```
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

// Headers for CppUnitTest
#include <Windows.h>
#include "CppUnitTest.h"

#include "../../../Assets/API/model.engine/Jit__Stage.h"
#include "../../../Assets/API/model.engine/Base__Machine.h"
#include "../../../Assets/API/model.engine/Machine__Flags.h"
#include "../../../Assets/API/model.engine/Engine.h"
#include "../../../Assets/API/model.engine/Shared__Tags.h"
#include "../../../Assets/API/model.engine/Model__Builder.h"
#include "../../../Assets/API/model.engine/Active__Builder.h"
#include "../../../Assets/API/model.engine/Chamber__Actions.h"
#include "../../../Assets/API/model.engine/Json__Helper.h"

#include "gmock/gmock.h"
```

**stdafx.cpp**
```
// stdafx.cpp : source file that includes just the standard includes
// model.engine.Tests.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// The following lines pull in the real gmock *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-cardinalities.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-internal-utils.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-matchers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock-spec-builders.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gmock.cc"

// The following lines pull in the real gtest *.cc files.
#include "../../../3rdParty/googletest-master/googlemock/src/gtest.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-death-test.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-filepath.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-port.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-printers.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-test-part.cc"
#include "../../../3rdParty/googletest-master/googlemock/src/gtest-typed-test.cc"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
```

Later you to **include** the `stadafx.h` in your mockfiles

```
#pragma once
#include "stdafx.h"
#include "../../../Assets/API/model.__engine/IBuildState__Manager.h"

namespace Cartman {
class MockBuildState__Manager : public IBuildState__Manager {		
public:

	MockBuildState__Manager() { };

	MOCK_METHOD(EPause__Condition, getPause__Condition, (), (const));

	MOCK_METHOD(EState, getCurrent__State, (), ());

	MOCK_METHOD(int, getRemaining__LayersToPause, (), (const));

	MOCK_METHOD(long long, getRemaining__AutoPauseTime, (), (const));

	MOCK_METHOD(void, update, (), ());
};	
```

NOTE: IF you checked the box for creating the precompiler header file and not included the pch.h/stdafx.h in your any of the source files then it will give error and **it should be top of all the headers in a file.**

## compile, build, rebuild, clean

When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn’t been modified doesn’t need to be recompiled -- the cached object file from last time can be reused. This can speed up compilation times significantly (at the cost of a little bit of disk space). <br>

With that in mind, here’s what each of the options typically does: <br>

- **Build** compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.
- **Clean** removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.
- **Rebuild** does a “clean”, followed by a “build”.

## Common C++ Problems

**Q: When compiling my program, I get a ‘no newline at end of file’ error** <br>
> The C++ standard requires that all source (.cpp) files end in a newline. It’s silly, but it is what it is. Go to the bottom of your source file(s), hit enter, save, and recompile

**Q: When I compile my program, I get a warning about "Cannot find or open the PDB file"** <br>
This is a warning, not an error, so it shouldn’t impact your program. However, it is annoying. To fix it, go into the Debug menu -> Options and Settings -> Symbols, and check “Microsoft Symbol Server”.

## Build Configuration

**General Settings**
- What the executable will be named
- What directories the IDE will look in for other code and library files
- Whether to keep or strip out debugging information
- How much to have the compiler optimize your program etc.

### Debug Confiuration
- This configuration turns off all optimizations
- Includes debugging information
- Makes your programs larger and slower
- The debug configuration is usually selected as the active configuration by default

### Release Configuration
 - This version is typically optimized for size and performance, and doesn’t contain the extra debugging information

**GCC/G++ Compiler**
Add `-ggdb` to the command line when debugging and `-O2 -DNDEBUG` for release builds. Use the former for now.

**Disable compiler extension - Visual Studio**
- To disable compiler extensions, right click on your project name in the Solution Explorer window, then choose **Properties**
- From the Project dialog, first make sure the Configuration field is set to **All Configurations**.
- Then, click C/C++ > Language tab, and set **Conformance mode to Yes (/permissive-)** (if it is not already set to that by default).
- For GCC/B++You can disable compiler extensions by adding the ```-pedantic-errors``` flag to the compile command line.


# Basics
source is [here](https://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/)

## Declaration vs Definition
- **Declaration** tells compiler about existense of a variable/function/symbol and it memory address and required storage may not be defined
- **Definition** tells the compiler about what the body of the variable/function/symbol contains and how much memory is required to store it
- In case of reference variables and pointers declarations along with definitions is necessary. In case of pointers they need to have a fixed memory independent of the memory type they are pointing to, in face in deferencing the pointer definition becomes important.

**Functions**
```
int f();               // declaration
int f() { return 42; } // definition
```

**Variables**
```
int x;		//both a declaration and definition
```
x in the case above is initialised with 0 via default constructor of int.

**Separating Declaration and Definition for variables**
```
extern int x; // declaration
int x = 42;   // definition
```

## Foward Declaration

In C++ we forward declare the variable/function with its **type and name without its definition**, so that we can use its body. Doing this save **unncessary compilation**.

_Example_
```
//someFile.hpp
class Class;
void f(Class object);
```
**One definition rule** : You can forward declare as many times as possible but definition can exist only once

# Virtual Table
When a function contains virtual function than virtual table corresponding to that class is generated during compile time.

Let's look at virtual table of this class:

```class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n\n"; };

};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n\n"; };

};
```

Virtual table of Base class:
*BaseClass contains a virtual function func2().
When an object of BaseClass is created, it contains a hidden virtual pointer (vptr) that points to the vtable of BaseClass.*
```
BaseClass vtable:
---------------------
| 0: Address of func2() |
---------------------
```
Virtual table of Derived class:

*DerivedClass also contains a virtual function func2(), which overrides the same function in BaseClass. When an object of DerivedClass is created, it contains a vptr that points to the vtable of DerivedClass.*
```
DerivedClass vtable:
---------------------
| 0: Address of DerivedClass::func2() |
---------------------
```

When a class is polymorphic (contains virtual functions), the compiler creates a hidden pointer in each object of that class. This pointer, called the **virtual pointer (vptr)**, points to the vtable of the dynamic type of the object.

# Static vs Dynamic vs Reinterpret Cast

## Static Casting
Static casting is done when you know the data types already:
E.g. conversion of float to int. The type is known during compile time.

## Dynamic Casting
Dynamic casting is done when the classes involved in conversion have virtual function and their behaviour is known during run time.
Types : Upcasting - derived to parent case class, where loss of information happens
Downcasting : parent to derived class : information can be restored.

```
class Base {
    virtual void foo() {};
};

class Derived : public Base {
    void foo () {};
};

Base* basePtr = new Derived;	//Upcasting - Loss of Information
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);	//Downcasting - Retrieve back information

if (derivedPtr) {
    // Successfully casted
} else {
    // Cast failed
}
```

### Casting Failure

```
class BaseClass
{
public:
	BaseClass() = default;
	~BaseClass() = default;

	void func1() { std::cout << "This is a base class func1\n"; };
	virtual void func2() { std::cout << "This is base class func2\n"; };
};

class DerivedClass : public BaseClass
{
public:
	DerivedClass() = default;
	~DerivedClass() = default;

	void func1() { std::cout << "This is a derived class func1\n"; };
	void func2() override { std::cout << "This is derived class func2\n"; };
};

int main()
{
	BaseClass *base = new BaseClass();
	base->func2();
	//downcasting
	DerivedClass* derived = dynamic_cast<DerivedClass*>(base); 

	derived->func2();
	// *Casting fails*
}
```

The dynamic casting fails because, intially base pointer points to BaseClass object.
In the dynamic casting we are making DerivedClass pointer point to Base class object where it fails.

```
DerivedClass* derived = dynamic_cast<DerivedClass*>(base);
```
During Dynamic Casting, the casting checks if the object being pointed to (Base class here by base *) by a pointer(Derived Class pointer here) is an instance of Derived Class or not.


## Reinterpret_Cast
It doesn't work on the basis of polymorphic behavior like Dynamic casting does.

In the code below:
```
DerivedClass* derived = reinterpret_cast<DerivedClass*>(base);
```
reinterpret_cast takes the BaseClass pointer base and forcefully reinterprets the bits of its address as if they were a DerivedClass pointer.
**It simply creates a new pointer of the target type with the same memory address as the original pointer.**

Since derived is a DerivedClass pointer, the compiler expects a DerivedClass object with its own virtual function table (vtable).
However, the actual object doesn't have a vtable for DerivedClass. It only has the vtable for BaseClass.
When derived->func2(); is called, the compiler incorrectly looks up func2 in the DerivedClass vtable, but it finds the base class version instead.  

reinterpret_cast only changes the pointer's type, not the underlying object's layout or behavior.
It doesn't magically insert the missing derived class members or vtable into the BaseClass object.
Technically, attempting to call a derived class function on a BaseClass object using a reinterpret_cast pointer is undefined behavior in C++.

# Function Pointers

## Typedef
```
typedef return_type (*FunctionPtr)(parameter_types...);

typedef void (*MyFunctionPtr)();
```

## using 
```
using FunctionPtr = return_type (*)(parameter_types...);

using MyFunctionPtr = void (*)();
```

## std::function
```
using FunctionType = std::function<return_type(parameter_types...)>;

using MyFunctionType = std::function<void()>;
```

# C-Style enums vs Class Enums

## Intro
C-Style enums
```
enum Color {green, yellow, blue};

int main()
{
	std::cout << green; //works
}
```

Class enums
```
enum Class Color {green, yellow, blue};

int main()
{
	std::cout << green;	   //doesn't work
	std::cout << Color::green; //works
}
```

## Differences
enum classes are better in these many ways:

1. enum classes can be type specified
```
enum class Color : unsigned int {  // Enum class with underlying type specified
    Red = 1,
    Green,
    Blue };
```

2. enum values can be initialized
```
enum class Day {  // Enum class without specified underlying type
    Monday = 1,
    Tuesday,
    Wednesday };
```
